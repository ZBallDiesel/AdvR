[
  {
    "objectID": "Ch13.html",
    "href": "Ch13.html",
    "title": "Chapter 13",
    "section": "",
    "text": "Exercises 13.2.1\n\nlibrary(sloop)\n\n\nt.test() and t.data.frame() perform very different functions. t.test() performs a t-test on provided data while t.data.frame transposes a matrix or dataframe. According to documentation and the workings of S3, t.data.frame() will be called when a user writes t(df) where df is a data frame. The documentation makes it appear that t.test() is typically called in that wording. However using t.test() on an object of type “test”–which I’m not aware of–should call t.test() if a user runs t(test) where test is an object of type test.\n\nlibrary(magrittr)\nbase_funs &lt;- lsf.str(\"package:base\", pattern = '.*\\\\..*')\n#base_funs \n\n\n\nFilter(function(x) {! (utils::isS3method(x) || utils::isS3stdGeneric(x))}, base_funs)\n\n  [1] \"all.names\"                \"all.vars\"                \n  [3] \"as.call\"                  \"as.character\"            \n  [5] \"as.complex\"               \"as.data.frame\"           \n  [7] \"as.data.frame.vector\"     \"as.difftime\"             \n  [9] \"as.double\"                \"as.environment\"          \n [11] \"as.factor\"                \"as.hexmode\"              \n [13] \"as.integer\"               \"as.logical\"              \n [15] \"as.name\"                  \"as.numeric\"              \n [17] \"as.numeric_version\"       \"as.octmode\"              \n [19] \"as.ordered\"               \"as.package_version\"      \n [21] \"as.pairlist\"              \"as.qr\"                   \n [23] \"as.raw\"                   \"as.symbol\"               \n [25] \"as.vector\"                \"attr.all.equal\"          \n [27] \"char.expand\"              \"data.class\"              \n [29] \"data.frame\"               \"data.matrix\"             \n [31] \"default.stringsAsFactors\" \"dir.create\"              \n [33] \"dir.exists\"               \"do.call\"                 \n [35] \"dyn.load\"                 \"dyn.unload\"              \n [37] \"env.profile\"              \"eval.parent\"             \n [39] \"expand.grid\"              \"file.access\"             \n [41] \"file.append\"              \"file.choose\"             \n [43] \"file.copy\"                \"file.create\"             \n [45] \"file.exists\"              \"file.info\"               \n [47] \"file.link\"                \"file.mode\"               \n [49] \"file.mtime\"               \"file.path\"               \n [51] \"file.remove\"              \"file.rename\"             \n [53] \"file.show\"                \"file.size\"               \n [55] \"file.symlink\"             \"find.package\"            \n [57] \"format.info\"              \"format.pval\"             \n [59] \"gc.time\"                  \"inverse.rle\"             \n [61] \"is.array\"                 \"is.atomic\"               \n [63] \"is.call\"                  \"is.character\"            \n [65] \"is.complex\"               \"is.data.frame\"           \n [67] \"is.double\"                \"is.element\"              \n [69] \"is.environment\"           \"is.expression\"           \n [71] \"is.factor\"                \"is.finite\"               \n [73] \"is.function\"              \"is.infinite\"             \n [75] \"is.integer\"               \"is.language\"             \n [77] \"is.list\"                  \"is.loaded\"               \n [79] \"is.logical\"               \"is.matrix\"               \n [81] \"is.na\"                    \"is.name\"                 \n [83] \"is.nan\"                   \"is.null\"                 \n [85] \"is.numeric\"               \"is.numeric_version\"      \n [87] \"is.object\"                \"is.ordered\"              \n [89] \"is.package_version\"       \"is.pairlist\"             \n [91] \"is.primitive\"             \"is.qr\"                   \n [93] \"is.R\"                     \"is.raw\"                  \n [95] \"is.recursive\"             \"is.single\"               \n [97] \"is.symbol\"                \"is.table\"                \n [99] \"is.unsorted\"              \"is.vector\"               \n[101] \"La.svd\"                   \"library.dynam\"           \n[103] \"library.dynam.unload\"     \"list.dirs\"               \n[105] \"list.files\"               \"lower.tri\"               \n[107] \"make.names\"               \"make.unique\"             \n[109] \"margin.table\"             \"mat.or.vec\"              \n[111] \"match.arg\"                \"match.call\"              \n[113] \"match.fun\"                \"max.col\"                 \n[115] \"mem.maxNSize\"             \"mem.maxVSize\"            \n[117] \"memory.profile\"           \"new.env\"                 \n[119] \"on.exit\"                  \"parent.env\"              \n[121] \"parent.env&lt;-\"             \"parent.frame\"            \n[123] \"path.expand\"              \"path.package\"            \n[125] \"pmax.int\"                 \"pmin.int\"                \n[127] \"pos.to.env\"               \"proc.time\"               \n[129] \"prop.table\"               \"qr.coef\"                 \n[131] \"qr.fitted\"                \"qr.Q\"                    \n[133] \"qr.qty\"                   \"qr.qy\"                   \n[135] \"qr.R\"                     \"qr.resid\"                \n[137] \"qr.solve\"                 \"qr.X\"                    \n[139] \"R.home\"                   \"R.Version\"               \n[141] \"read.dcf\"                 \"reg.finalizer\"           \n[143] \"rep.int\"                  \"sample.int\"              \n[145] \"save.image\"               \"seq.int\"                 \n[147] \"set.seed\"                 \"sink.number\"             \n[149] \"slice.index\"              \"sort.int\"                \n[151] \"sort.list\"                \"storage.mode\"            \n[153] \"storage.mode&lt;-\"           \"sys.call\"                \n[155] \"sys.calls\"                \"Sys.chmod\"               \n[157] \"Sys.Date\"                 \"sys.frame\"               \n[159] \"sys.frames\"               \"sys.function\"            \n[161] \"Sys.getenv\"               \"Sys.getlocale\"           \n[163] \"Sys.getpid\"               \"Sys.glob\"                \n[165] \"Sys.info\"                 \"sys.load.image\"          \n[167] \"Sys.localeconv\"           \"sys.nframe\"              \n[169] \"sys.on.exit\"              \"sys.parent\"              \n[171] \"sys.parents\"              \"Sys.readlink\"            \n[173] \"sys.save.image\"           \"Sys.setenv\"              \n[175] \"Sys.setFileTime\"          \"Sys.setLanguage\"         \n[177] \"Sys.setlocale\"            \"Sys.sleep\"               \n[179] \"sys.source\"               \"sys.status\"              \n[181] \"Sys.time\"                 \"Sys.timezone\"            \n[183] \"Sys.umask\"                \"Sys.unsetenv\"            \n[185] \"Sys.which\"                \"system.file\"             \n[187] \"system.time\"              \"unix.time\"               \n[189] \"upper.tri\"                \"which.max\"               \n[191] \"which.min\"                \"write.dcf\"               \n[193] \"xpdrows.data.frame\"      \n\n\nHere are the base R functions that have a dot in their name and are not S3 methods or generics.\n\nas.data.frame.data.frame() is for using as.data.frame(df) where df is already a data frame. Ie, it tries to convert a data frame into a data frame. This confusing name can be avoided by not using dots when naming functions outside of S3 method usage.\nFor reference:\n\nset.seed(1014)\nsome_days &lt;- as.Date(\"2017-01-31\") + sample(10, 5)\n\nmean(some_days)\n\n[1] \"2017-02-06\"\n\n#&gt; [1] \"2017-02-06\"\nmean(unclass(some_days))\n\n[1] 17203.4\n\n#&gt; [1] 17203\n\n\nIn the first call, some_days is interpreted as a date, whereas the second call to mean treats some_days as a numeric vector due to being unclassed.\n\n\nx &lt;- ecdf(rpois(100, 10))\nx\n\nEmpirical CDF \nCall: ecdf(rpois(100, 10))\n x[1:18] =      2,      3,      4,  ...,     18,     19\n\n#&gt; Empirical CDF \n#&gt; Call: ecdf(rpois(100, 10))\n#&gt;  x[1:18] =  2,  3,  4,  ..., 2e+01, 2e+01\nstr(x)\n\nfunction (v)  \n - attr(*, \"class\")= chr [1:3] \"ecdf\" \"stepfun\" \"function\"\n - attr(*, \"call\")= language ecdf(rpois(100, 10))\n\nstr(unclass(x))\n\nfunction (v)  \n - attr(*, \"call\")= language ecdf(rpois(100, 10))\n\n\n\nx is an object of type “ecdf” and “stepfun” built on top of base R type closure. It uses attributes “class”, and “call”\n\n\nx &lt;- table(rpois(100, 5))\nx\n\n\n 1  2  3  4  5  6  7  8  9 10 \n 7  5 18 14 15 15 14  4  5  3 \n\n#&gt; \n#&gt;  1  2  3  4  5  6  7  8  9 10 \n#&gt;  7  5 18 14 15 15 14  4  5  3\nstr(x)\n\n 'table' int [1:10(1d)] 7 5 18 14 15 15 14 4 5 3\n - attr(*, \"dimnames\")=List of 1\n  ..$ : chr [1:10] \"1\" \"2\" \"3\" \"4\" ...\n\ntypeof(x)\n\n[1] \"integer\"\n\nis.vector(x)\n\n[1] FALSE\n\nstr(unclass(x))\n\n int [1:10(1d)] 7 5 18 14 15 15 14 4 5 3\n - attr(*, \"dimnames\")=List of 1\n  ..$ : chr [1:10] \"1\" \"2\" \"3\" \"4\" ...\n\nis.vector(unclass(x))\n\n[1] FALSE\n\n\n\nx is of class “table” which is built on top of “integer” with attribute “dimnames”\n13.3.4 Exercises\n\n\nnew_data.frame &lt;- function(..., row.names = NULL){\n    res &lt;- list(...)\n    #class(res) &lt;- \"data.frame\"\n    #attr(res, \"row.names\") &lt;- row.names\n    if(is.null(row.names)){\n        row_n &lt;- 1:length(res[[0]])\n    } else {\n        row_n &lt;- row.names\n    }\n    return (structure(res, class = \"data.frame\", row.names = row_n))\n}\n\n\nnew_factor &lt;- function(x = integer(), levels = character()) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\nvalidate_factor &lt;- function(x) {\n  values &lt;- unclass(x)\n  levels &lt;- attr(x, \"levels\")\n\n  if (!all(!is.na(values) & values &gt; 0)) {\n    stop(\n      \"All `x` values must be non-missing and greater than zero\",\n      call. = FALSE\n    )\n  }\n\n  if (length(levels) &lt; max(values)) {\n    stop(\n      \"There must be at least as many `levels` as possible values in `x`\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\nmy_factor &lt;- function(x = character(), levels = unique(x)) {\n    levels &lt;- c(levels, x[!(x %in% levels)])\n  ind &lt;- match(x, levels)\n  validate_factor(new_factor(ind, levels))\n}\n\nmy_factor(c(\"a\", \"a\", \"b\"))\n\n[1] a a b\nLevels: a b\n\n#&gt; [1] a a b\n#&gt; Levels: a b\n\n\nbase::factor() will write values in x not present in levels to NA.\n\n\nprint(base::factor)\n\nfunction (x = character(), levels, labels = levels, exclude = NA, \n    ordered = is.ordered(x), nmax = NA) \n{\n    if (is.null(x)) \n        x &lt;- character()\n    nx &lt;- names(x)\n    if (missing(levels)) {\n        y &lt;- unique(x, nmax = nmax)\n        ind &lt;- order(y)\n        levels &lt;- unique(as.character(y)[ind])\n    }\n    force(ordered)\n    if (!is.character(x)) \n        x &lt;- as.character(x)\n    levels &lt;- levels[is.na(match(levels, exclude))]\n    f &lt;- match(x, levels)\n    if (!is.null(nx)) \n        names(f) &lt;- nx\n    if (missing(labels)) {\n        levels(f) &lt;- as.character(levels)\n    }\n    else {\n        nlab &lt;- length(labels)\n        if (nlab == length(levels)) {\n            nlevs &lt;- unique(xlevs &lt;- as.character(labels))\n            at &lt;- attributes(f)\n            at$levels &lt;- nlevs\n            f &lt;- match(xlevs, nlevs)[f]\n            attributes(f) &lt;- at\n        }\n        else if (nlab == 1L) \n            levels(f) &lt;- paste0(labels, seq_along(levels))\n        else stop(gettextf(\"invalid 'labels'; length %d should be 1 or %d\", \n            nlab, length(levels)), domain = NA)\n    }\n    class(f) &lt;- c(if (ordered) \"ordered\", \"factor\")\n    f\n}\n&lt;bytecode: 0x12b8fe6d0&gt;\n&lt;environment: namespace:base&gt;\n\n\n\nFeatures present in base::factor and not included in Hadley’s factor include: protection against a user feeding a null value for x, a potential to specify the maximum amount of levels, and handling of x values not present in levels as NA.\n\nContrasts controls the encoding of factors when encoding non-numeric data during modeling. To be consistent with C() should be a numeric matrix, the name of a function to provide the matrix, or the function itself.\n\n```{r}\nnew_factor &lt;- function(x = integer(), levels = character(), contrast = NULL) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n    if (is.function(contrast)){\n        contrast &lt;- contrast(x)\n    } else if (is.character(contrast)){\n        contrast &lt;- get(contrast)(x)\n    } else if ((is.null(constrasts)) || (is.matrix(constrasts) && is.numeric(constrasts)) ){\n        \n    } else {\n        stop(\"Unsuitbale contrast input\")\n    }\n  \n  structure(\n    x,\n    levels = levels,\n    class = \"factor\",\n    contrasts = contrast\n  )\n}\n```\n\nSince roman class is stored as the integers that are to be represented, a constructor would simply check that the input is integer (or coerce double to integer) and set the class to roman. A validator would be a good idea; however, the simplicity of the class means that there is little to validate. A helper would likely just call the constructor. The heavy lifting in this type is done by the methods.\n\n13.4.4 Exercises\n\n\nprint(t)\n\nfunction (x) \nUseMethod(\"t\")\n&lt;bytecode: 0x10dffc998&gt;\n&lt;environment: namespace:base&gt;\n\nprint(t.test)\n\nfunction (x, ...) \nUseMethod(\"t.test\")\n&lt;bytecode: 0x10b1228d8&gt;\n&lt;environment: namespace:stats&gt;\n\nutils::isS3stdGeneric(t.test)\n\nt.test \n  TRUE \n\nutils::isS3method(\"t.test\")\n\n[1] FALSE\n\nx &lt;- structure(1:10, class = \"test\")\ns3_dispatch(t(x))\n\n=&gt; t.test\n * t.default\n\n\n\nIf you create an object with class test and call t() on it, t.test() will be called. This is confirmed by my experiment above.\n\n\ns3_methods_class(\"table\")\n\n# A tibble: 10 × 4\n   generic       class visible source             \n   &lt;chr&gt;         &lt;chr&gt; &lt;lgl&gt;   &lt;chr&gt;              \n 1 [             table TRUE    base               \n 2 aperm         table TRUE    base               \n 3 as.data.frame table TRUE    base               \n 4 Axis          table FALSE   registered S3method\n 5 lines         table FALSE   registered S3method\n 6 plot          table FALSE   registered S3method\n 7 points        table FALSE   registered S3method\n 8 print         table TRUE    base               \n 9 summary       table TRUE    base               \n10 tail          table FALSE   registered S3method\n\n\n\n\n\n\ns3_methods_class(\"ecdf\")\n\n# A tibble: 4 × 4\n  generic  class visible source             \n  &lt;chr&gt;    &lt;chr&gt; &lt;lgl&gt;   &lt;chr&gt;              \n1 plot     ecdf  TRUE    stats              \n2 print    ecdf  FALSE   registered S3method\n3 quantile ecdf  FALSE   registered S3method\n4 summary  ecdf  FALSE   registered S3method\n\n\n\nlibrary(purrr)\n\n\nAttaching package: 'purrr'\n\n\nThe following object is masked from 'package:magrittr':\n\n    set_names\n\nbase_gens &lt;- Filter(is_s3_generic , lsf.str(\"package:base\")) \nlens &lt;- base_gens %&gt;% \n    purrr::map_int(function(x) {nrow(s3_methods_generic(x))}) \nbase_gens[lens == max(lens)]\n\n[1] \"print\"\n\n\n\nprint is our answer, unsurprisingly.\n\n\ng &lt;- function(x) {\n  x &lt;- 10\n  y &lt;- 10\n  UseMethod(\"g\")\n}\ng.default &lt;- function(x) c(x = x, y = y)\n\nx &lt;- 1\ny &lt;- 1\ng(x)\n\n x  y \n 1 10 \n\n#&gt;  x  y \n#&gt;  1 10\n\n\nWhen g(1) is called, 1 has type default, so UseMethod(“g”) finds g.default() to use. A special property of UseMethod is that it copies the arguments from the generic function to use as arguments to the method function. Thus, writing x &lt;- 10 has no effect as g.default uses x = 1 from the argument of the generic. Then it looks in the above environmenmt for y since y is not found in the existing env of g.default and finds y = 10, so that value is used.\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ tidyr::extract()   masks magrittr::extract()\n✖ dplyr::filter()    masks stats::filter()\n✖ dplyr::lag()       masks stats::lag()\n✖ purrr::set_names() masks magrittr::set_names()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nprint(`[`)\n\n.Primitive(\"[\")\n\nprint(names(formals(`[`)))\n\nNULL\n\nprint(names(formals(`[.data.frame`)))\n\n[1] \"x\"    \"i\"    \"j\"    \"drop\"\n\ns3_methods_generic(\"[\") %&gt;%\n    filter(visible) %&gt;%\n    mutate(full_name = paste0(\"[.\", class),\n        args = purrr::map(full_name, formals)) %&gt;%\n    select(full_name, args)\n\n# A tibble: 17 × 2\n   full_name         args      \n   &lt;chr&gt;             &lt;list&gt;    \n 1 [.AsIs            &lt;pairlist&gt;\n 2 [.data.frame      &lt;pairlist&gt;\n 3 [.Date            &lt;pairlist&gt;\n 4 [.difftime        &lt;pairlist&gt;\n 5 [.Dlist           &lt;pairlist&gt;\n 6 [.DLLInfoList     &lt;pairlist&gt;\n 7 [.factor          &lt;pairlist&gt;\n 8 [.hexmode         &lt;pairlist&gt;\n 9 [.listof          &lt;pairlist&gt;\n10 [.noquote         &lt;pairlist&gt;\n11 [.numeric_version &lt;pairlist&gt;\n12 [.octmode         &lt;pairlist&gt;\n13 [.POSIXct         &lt;pairlist&gt;\n14 [.POSIXlt         &lt;pairlist&gt;\n15 [.simple.list     &lt;pairlist&gt;\n16 [.table           &lt;pairlist&gt;\n17 [.warnings        &lt;pairlist&gt;\n\n\n\n[ is a primitive function, which makes its source code difficult to view. Additionally, the generic function itself will not reveal its arguments except for a specific class. As you can see, the number of argument is different for each class.\n13.5.1 Exercises\n\nlm() – scalar obj\nfactor() – vector type\ntable() - vector type\nas.Date() - vector type\nas.POSIXct - vector type\necdf() - this returns a closure so I’m not sure how it fits these categories (perhaps scalar obj?)\nordered() - vector type\nI() - typically a data frame style object\nA constructor for lm will require checking the many arguments, running according to them, and calculating the resulting linear model then placing it into the final list for returning.\n\n13.6.3 Exercises\n\n\nprint(`[.Date`)\n\nfunction (x, ..., drop = TRUE) \n{\n    .Date(NextMethod(\"[\"), oldClass(x))\n}\n&lt;bytecode: 0x10c6fb7b0&gt;\n&lt;environment: namespace:base&gt;\n\nprint(`.Date`)\n\nfunction (xx, cl = \"Date\") \n`class&lt;-`(xx, cl)\n&lt;bytecode: 0x10b758f78&gt;\n&lt;environment: namespace:base&gt;\n\n\n\nBased on the [.Date function and the .Date constructor, it appears that the class will be restored for any objects with a class other than Date (i.e. Date subclasses). However, it is possible that other metadata may be lost.\n\n\nprint(nrow(s3_methods_class(\"POSIXct\") ))\n\n[1] 20\n\nprint(nrow(s3_methods_class(\"POSIXlt\")))\n\n[1] 34\n\nsetdiff(s3_methods_class(\"POSIXt\")$generic, \n        union(s3_methods_class(\"POSIXct\")$generic, \n              s3_methods_class(\"POSIXlt\")$generic))\n\n [1] \"-\"             \"!=\"            \"+\"             \"&lt;\"            \n [5] \"&lt;=\"            \"==\"            \"&gt;\"             \"&gt;=\"           \n [9] \"all.equal\"     \"as.character\"  \"Axis\"          \"cut\"          \n[13] \"diff\"          \"hist\"          \"is.numeric\"    \"julian\"       \n[17] \"Math\"          \"months\"        \"Ops\"           \"output_column\"\n[21] \"pretty\"        \"quantile\"      \"quarters\"      \"round\"        \n[25] \"scale_type\"    \"seq\"           \"str\"           \"trunc\"        \n[29] \"tz\"            \"update\"        \"weekdays\"     \n\n\n\nThere are 21 generic methods that both POSIXlt and POSIXct inherit from POSIXt, thus ensuring equivalent behavior. POSIXct has 18 of its own methods, and POSIXlt has 33 of its own methods, which will likely have different functionality. It is reasonable to assume that functions that are in the subclass method have different funcitonality since, if otherwise, the developer would simply forgo creating one and let R find the superclass method to use.\n\nI expect this code to return “a2”. I’ll elaborate the steps to reach this conclusion: the object initially has class c(“b”, “a2”) so the generic2.b() will be called. Like UseMethod(), NextMethod() directly uses the arguments to generic2.b(), thus meaning that changing the class of x to “a1” has no effect. Hence, generic2.a2() is called, whose return value “a2” percolates up through the function chain to be returned.\n\n```{r}\ngeneric2 &lt;- function(x) UseMethod(\"generic2\")\ngeneric2.a1 &lt;- function(x) \"a1\"\ngeneric2.a2 &lt;- function(x) \"a2\"\ngeneric2.b &lt;- function(x) {\n  class(x) &lt;- \"a1\"\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n```\nNice!\n13.7.5 Exercises\n\nFor reference:\n\nlength.integer &lt;- function(x) 10\n\nx1 &lt;- 1:5\nclass(x1)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\nprint(s3_class(x1))\n\n[1] \"integer\" \"numeric\"\n\ns3_dispatch(length(x1))\n\n * length.integer\n   length.numeric\n   length.default\n=&gt; length (internal)\n\n#&gt;  * length.integer\n#&gt;    length.numeric\n#&gt;    length.default\n#&gt; =&gt; length (internal)\n\nx2 &lt;- structure(x1, class = \"integer\")\nclass(x2)\n\n[1] \"integer\"\n\n#&gt; [1] \"integer\"\nprint(s3_class(x2))\n\n[1] \"integer\"\n\ns3_dispatch(length(x2))\n\n=&gt; length.integer\n   length.default\n * length (internal)\n\n#&gt; =&gt; length.integer\n#&gt;    length.default\n#&gt;  * length (internal)\n\n\nWhile class(x1) returns “integer”, we see that the implicit class it has is “integer” inheriting from “numeric”. As mentioned in the book, R treats these vectors differently, so thus it does it typical sequence of function calls on x1, ultimately using length (internal). Note that length.integer is found but not called due to these rules. However, the class of x2 is manually overridden to “integer” without numeric inheritance. Thus, R follows the S3 function calling convention and calls length.integer for x2 since we made that function.\n\n\nprint(s3_methods_generic(\"Math\"))\n\n# A tibble: 8 × 4\n  generic class      visible source             \n  &lt;chr&gt;   &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt;              \n1 Math    data.frame TRUE    base               \n2 Math    Date       TRUE    base               \n3 Math    difftime   TRUE    base               \n4 Math    factor     TRUE    base               \n5 Math    POSIXt     TRUE    base               \n6 Math    quosure    FALSE   registered S3method\n7 Math    vctrs_sclr FALSE   registered S3method\n8 Math    vctrs_vctr FALSE   registered S3method\n\nprint(Math.difftime)\n\nfunction (x, ...) \n{\n    switch(.Generic, abs = , sign = , floor = , ceiling = , trunc = , \n        round = , signif = {\n            units &lt;- attr(x, \"units\")\n            .difftime(NextMethod(), units)\n        }, stop(gettextf(\"'%s' not defined for \\\"difftime\\\" objects\", \n            .Generic), domain = NA))\n}\n&lt;bytecode: 0x10cb413e0&gt;\n&lt;environment: namespace:base&gt;\n\nprint(Math)\n\nnew(\"groupGenericFunction\", .Data = function (x) \nstandardGeneric(\"Math\"), groupMembers = list(\"abs\", \"sign\", \"sqrt\", \n    \"ceiling\", \"floor\", \"trunc\", \"cummax\", \"cummin\", \"cumprod\", \n    \"cumsum\", \"exp\", \"expm1\", \"log\", \"log10\", \"log2\", \"log1p\", \n    \"cos\", \"cosh\", \"sin\", \"sinh\", \"tan\", \"tanh\", \"acos\", \"acosh\", \n    \"asin\", \"asinh\", \"atan\", \"atanh\", \"cospi\", \"sinpi\", \"tanpi\", \n    \"gamma\", \"lgamma\", \"digamma\", \"trigamma\"), generic = \"Math\", \n    package = \"base\", group = list(), valueClass = character(0), \n    signature = \"x\", default = NULL, skeleton = (function (x) \n    stop(gettextf(\"invalid call in method dispatch to '%s' (no default method)\", \n        \"Math\"), domain = NA))(x))\n&lt;bytecode: 0x10b4cada0&gt;\n&lt;environment: 0x11a908bf8&gt;\nattr(,\"generic\")\n[1] \"Math\"\nattr(,\"generic\")attr(,\"package\")\n[1] \"base\"\nattr(,\"package\")\n[1] \"base\"\nattr(,\"group\")\nlist()\nattr(,\"valueClass\")\ncharacter(0)\nattr(,\"signature\")\n[1] \"x\"\nattr(,\"default\")\n`\\001NULL\\001`\nattr(,\"skeleton\")\n(function (x) \nstop(gettextf(\"invalid call in method dispatch to '%s' (no default method)\", \n    \"Math\"), domain = NA))(x)\nattr(,\"groupMembers\")\nattr(,\"groupMembers\")[[1]]\n[1] \"abs\"\n\nattr(,\"groupMembers\")[[2]]\n[1] \"sign\"\n\nattr(,\"groupMembers\")[[3]]\n[1] \"sqrt\"\n\nattr(,\"groupMembers\")[[4]]\n[1] \"ceiling\"\n\nattr(,\"groupMembers\")[[5]]\n[1] \"floor\"\n\nattr(,\"groupMembers\")[[6]]\n[1] \"trunc\"\n\nattr(,\"groupMembers\")[[7]]\n[1] \"cummax\"\n\nattr(,\"groupMembers\")[[8]]\n[1] \"cummin\"\n\nattr(,\"groupMembers\")[[9]]\n[1] \"cumprod\"\n\nattr(,\"groupMembers\")[[10]]\n[1] \"cumsum\"\n\nattr(,\"groupMembers\")[[11]]\n[1] \"exp\"\n\nattr(,\"groupMembers\")[[12]]\n[1] \"expm1\"\n\nattr(,\"groupMembers\")[[13]]\n[1] \"log\"\n\nattr(,\"groupMembers\")[[14]]\n[1] \"log10\"\n\nattr(,\"groupMembers\")[[15]]\n[1] \"log2\"\n\nattr(,\"groupMembers\")[[16]]\n[1] \"log1p\"\n\nattr(,\"groupMembers\")[[17]]\n[1] \"cos\"\n\nattr(,\"groupMembers\")[[18]]\n[1] \"cosh\"\n\nattr(,\"groupMembers\")[[19]]\n[1] \"sin\"\n\nattr(,\"groupMembers\")[[20]]\n[1] \"sinh\"\n\nattr(,\"groupMembers\")[[21]]\n[1] \"tan\"\n\nattr(,\"groupMembers\")[[22]]\n[1] \"tanh\"\n\nattr(,\"groupMembers\")[[23]]\n[1] \"acos\"\n\nattr(,\"groupMembers\")[[24]]\n[1] \"acosh\"\n\nattr(,\"groupMembers\")[[25]]\n[1] \"asin\"\n\nattr(,\"groupMembers\")[[26]]\n[1] \"asinh\"\n\nattr(,\"groupMembers\")[[27]]\n[1] \"atan\"\n\nattr(,\"groupMembers\")[[28]]\n[1] \"atanh\"\n\nattr(,\"groupMembers\")[[29]]\n[1] \"cospi\"\n\nattr(,\"groupMembers\")[[30]]\n[1] \"sinpi\"\n\nattr(,\"groupMembers\")[[31]]\n[1] \"tanpi\"\n\nattr(,\"groupMembers\")[[32]]\n[1] \"gamma\"\n\nattr(,\"groupMembers\")[[33]]\n[1] \"lgamma\"\n\nattr(,\"groupMembers\")[[34]]\n[1] \"digamma\"\n\nattr(,\"groupMembers\")[[35]]\n[1] \"trigamma\"\n\nattr(,\"class\")\n[1] \"groupGenericFunction\"\nattr(,\"class\")attr(,\"package\")\n[1] \"methods\"\n\n\n\nThere are 8 classes with a Math group generic in base R, including data.frame, Date, difftime, factor, POSIXt, quosure, vctrs_sclr, vctrs_vctr. The Math generic is a collection of many functions as a group generic. To see, I looked at the code for one of the methods, Math.difftime, which is composed primarily by a large switch function to facilitate the many different operations that may be requested.\n\nMath.difftime has additional complication due to having to deal with inheritance of the difftime class (we can see that Math.difftime calls nextMethod()) and since some operations are not defined on difftime objects. For example, it does not make sense to perform trigonometric operations on a difftime object."
  },
  {
    "objectID": "Ch8.html",
    "href": "Ch8.html",
    "title": "Chapter 8",
    "section": "",
    "text": "8.2.4 Exercises\n\n\nmy_file_rmv &lt;- function(...){\n    if (all(file.exists(...))){\n        file.remove(...)\n        return(T)\n    }\n    stop(\"Some file to be removed does not exist.\", call. = F)\n}\n\nappendLF is a boolean argument that tells message() if it should append a new line–ie “\\n”–to the end of the message. cat() has a similar argument named fill that determines if a new line will be placed between each argument to be printed.\n\n8.4.5 Exercises\n\nabort() saves a backtrace in the trace component of the error condition.\nMy predictions are:\n“error”\nNULL\n“warning”\n“message”\nNow lets see what happens\n\nshow_condition &lt;- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition(stop(\"!\"))\n\n[1] \"error\"\n\nshow_condition(10)\n\nNULL\n\nshow_condition(warning(\"?!\"))\n\n[1] \"warning\"\n\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n\n[1] \"message\"\n\n\n\nNice.\n\nThe outer call handler runs its code section, which contains the inner call handler–which in turn runs its code section containing the message(“c”). Now that a message has occurred, the inner call handler for messages is launched, returning a message of “a”. However, this message statement launches the outer call handler, which runs message(“b”) uninterrupted so ‘b’ is printed to the console. Then what launched the outer call handler can continue, thus a is printed. Now what launched the inner call handler can run, so message(“c”) can continue. However, now the outer call handler must handle it–since it has not encountered it before–so b is printed again. Finally, c can run unobstructed so c is printed.\n\n\nlibrary(rlang)\nprint(catch_cnd)\n\nfunction (expr, classes = \"condition\") \n{\n    stopifnot(is_character(classes))\n    handlers &lt;- rep_named(classes, list(identity))\n    eval_bare(rlang::expr(tryCatch(!!!handlers, {\n        force(expr)\n        return(NULL)\n    })))\n}\n&lt;bytecode: 0x12f0fe860&gt;\n&lt;environment: namespace:rlang&gt;\n\n\nThe first line simply verifies that the classes input is valid as a character vector. handlers will be a vector with the identity function for each class specified. The tryCatch block executes the provided code and captures the condition if it is part of a specified class. Otherwise, Null is returned.\n\nmy_show_cond &lt;- function(code){\n    tryCatch(\n        condition = function(cnd) (attr(cnd, \"class\"))[2],\n        {code \n            NULL}\n    )\n}\n\nmy_show_cond(stop(\"!\"))\n\n[1] \"error\"\n\nmy_show_cond(10)\n\nNULL\n\nmy_show_cond(warning(\"?!\"))\n\n[1] \"warning\"\n\nmy_show_cond({\n    10\n    message(\"?\")\n    warning(\"?!\")\n})\n\n[1] \"message\"\n\n\n\n8.5.4 Exercises\n\n\ncheck_pkg &lt;- function(pkg){\n    worked &lt;- requireNamespace(pkg, quietly = FALSE)\n    if(!worked){\n        abort(\n            \"error - package not found\", \n            message = paste0(pkg, \" not installed\"),\n            pkg = pkg\n        )\n    }\n\n    return(T)\n}\n\ncheck_pkg(\"rlang\")\n\n[1] TRUE\n\ncheck_pkg(\"tidyverse\")\n\nLoading required namespace: tidyverse\n\n\n[1] TRUE\n\ntryCatch(check_pkg(\"zball\"), error = function(cnd) print(cnd))\n\nLoading required namespace: zball\n\n\n&lt;error/error - package not found&gt;\nError in `check_pkg()`:\n! zball not installed\n---\nBacktrace:\n    ▆\n 1. ├─base::tryCatch(check_pkg(\"zball\"), error = function(cnd) print(cnd))\n 2. │ └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n 3. │   └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n 4. │     └─base (local) doTryCatch(return(expr), name, parentenv, handler)\n 5. └─global check_pkg(\"zball\")\n\n\nWe could try to communicate the error via alternative methods. For example, we could use typical C methods where we return a special value if an error occurs.\n\n8.6.6 Exercises\n\n\nprint(suppressMessages)\n\nfunction (expr, classes = \"message\") \nwithCallingHandlers(expr, message = function(c) if (inherits(c, \n    classes)) tryInvokeRestart(\"muffleMessage\"))\n&lt;bytecode: 0x12ceb9430&gt;\n&lt;environment: namespace:base&gt;\n\nprint(suppressWarnings)\n\nfunction (expr, classes = \"warning\") \n{\n    withCallingHandlers(expr, warning = function(w) if (inherits(w, \n        classes)) \n        tryInvokeRestart(\"muffleWarning\"))\n}\n&lt;bytecode: 0x13bd5be98&gt;\n&lt;environment: namespace:base&gt;\n\n\n\n\nlibrary(rlang)\n\nsuppressConditions &lt;- function(expr){\n    tryCatch(condition = function(cnd) invisible(cnd), expr)\n}\n\nerror_obj &lt;- suppressConditions({\n  message(\"message\")\n  warning(\"warning\")\n  abort(\"error\")\n})\n\nerror_obj\n\n&lt;simpleMessage in message(\"message\"): message\n&gt;\n\n\n\n\nmessage2error &lt;- function(code) {\n  withCallingHandlers(code, message = function(e) stop(e))\n}\n print(message2error( message(\"message 1\")))\n\nmessage 1\n\n\nNULL\n\n traceback()\n\nNo traceback available \n\nmessage2error &lt;- function(code) {\n  tryCatch(code, message = function(e) stop(e))\n}\n#print(message2error( message(\"message 2\")))\n\n\n\nmessage(\"hi\")\n\nhi\n\n\nI appear to be getting equivalent results from both. Perhaps something is wrong.\n\ncatch_cnds appears to return warnings and messages in original order based on my analysis of the code and the empirical data.\nI hope this code doesn’t do something bad!!!\n\nbottles_of_beer &lt;- function(i = 99) {\n  message(\n    \"There are \", i, \" bottles of beer on the wall, \", \n    i, \" bottles of beer.\"\n  )\n  while(i &gt; 0) {\n    tryCatch(\n      Sys.sleep(1),\n      interrupt = function(err) {\n        i &lt;&lt;- i - 1\n        if (i &gt; 0) {\n          message(\n            \"Take one down, pass it around, \", i, \n            \" bottle\", if (i &gt; 1) \"s\", \" of beer on the wall.\"\n          )\n        }\n      }\n    )\n  }\n  message(\n    \"No more bottles of beer on the wall, \", \n    \"no more bottles of beer.\"\n  )\n}\n\n\n\n#bottles_of_beer()\n\nDuring my testing of this function, attempting to interrupt more than once causes R to crash curiously. The problem with this code is that the while loop will only terminate if we decrement i 100 times due to interrupting R 100 times. This alone would be tedious if we want to exit the function and move on with our lives. To compound the problems here, R is put to sleep while in the while loop so that we can not interrupt R. As soon as R exits its 1 second sleep, the tryCatch will have run succesfully and i will not have been decremented, causing the loop to run again. Essentially, this will be an infinite loop. The general problem with catching interrupts is that users typically want the interrupt to actually interrupt the function."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AdvancedR",
    "section": "",
    "text": "Welcome to Zach’s Quarto site on Advanced R.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Ch6.html",
    "href": "Ch6.html",
    "title": "Chapter 6",
    "section": "",
    "text": "6.2.5 Exercises\n\nIf you have a function, you need some way to refer to it to use any sorts of name lookup system. But then, you would already know the name of the function, thus eliminating the need to look up its name.\nThe lower approach is correct. In the upper line, R interperts the last parentheses as being part of the body of the function, so the line simply returns a function. In the lower line, the function being surrounded in parentheses lets R know that that is a function and the last parentheses are calling it.\n\n#function(x) 3()\n#&gt; function(x) 3()\n(function(x) 3)()\n\n[1] 3\n\n#&gt; [1] 3\n\nI do not have code to review.\nis.function() and is.primitive() will work for those purposes respectively.\n\nobjs &lt;- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns &lt;- Filter(is.function, objs)\n\n\na.\n\ntypeof(funs)\n\n[1] \"list\"\n\nlibrary(purrr)\n\narg_len &lt;- funs %&gt;% \n    map(formals) %&gt;%\n    map_int(length)\n\narg_len %&gt;%\n    sort(decreasing = TRUE) %&gt;%\n    head()\n\n            scan   format.default           source          formatC \n              22               16               16               15 \n         library merge.data.frame \n              13               13 \n\n\nscan has the most arguments with 22.\nb.\n\nsum(arg_len == 0)\n\n[1] 253\n\n\n253 functions have no arguments.\nc.\n\nlength(Filter(is.primitive, objs))\n\n[1] 205\n\n\nThere are 205 primitive functions.\n\nFormals, Body, and Environment\nThe environment is not shown if the function is defined in the global environment.\n\n6.4.5 Exercises\n\n\nc &lt;- 10\nc(c = c)\n\n c \n10 \n\n\n\nSince the leftmost c is scripted, R looks for a function with the name c, finding the concatenate function. For the c on the left of the assignment operator (=), it is known that this will be the name of an argument so it is taken as a literal. For the rightmost c, it is the value of an argument, so it is evaluated, leading to the value of 10 due to the previous line of code.\n\nName masking\nFunctions versus variables\nA fresh start\nDynamic lookup\nI predict a value of 202.\n\n```{r}\nf &lt;- function(x) {\n  f &lt;- function(x) {\n    f &lt;- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nprint(f(10))\n```\nCorrect!\n6.5.4 Exercises\n\nx_ok() utilizing the shortcircuting property of &&. This makes the program run properly even if one of the right statements will will error (such as NULL &gt; 0), as the the left side statements will evaluate to FALSE if the right statement would error. The & operator does not shortcircuit as it needs to evaluate all elements of a vector. This will lead to different operation. For example, the x_ok(1:3) will return a length 3 vector, while we might want a single logical value (such as where the result may be used in an if statement).\nI think that 100 will be returned.\n\n\nf2 &lt;- function(x = z) {\n  z &lt;- 100\n  x\n}\nf2()\n\n[1] 100\n\n\nThis is due to R’s principle of lazy evaluation and how R evaluates default values. Since the function call uses the default value, we have a promise of x = z that will be evaluated in the function environment. Due to lazy evaluation, we will not evaluate x = z until x is used in the last line of the function. At this point, we already have z = 100 in the function environment, thus we get x = z = 100.\n\nI predict that this code will output [1, 2, 1] then 10. Let’s see.\n\ny &lt;- 10\nf1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) {\n  c(x, y)\n}\nprint(f1())\n\n[1] 2 1\n\nprint(y)\n\n[1] 10\n\n\n\nLooks like I was mostly correct. We actually get [2, 1]. I misunderstood what {y &lt;- 1; 2} will cause to happen. It appears that it evaluates y &lt;- 1 and sets x = 2 rather then evaluate y &lt;- 1 and set x = [1, 2]. These results occur due to lazy evaluation. Since x is to the left of y in c(x, y), x is first evaluated, which sets y = 1 and x = 2. Then y is evaluated for c(x, y). Since y already now exists in the environment, that value of y = 1 is used and the default argument y = 0 is ignored. Since {y &lt;- 1; 2} is a default argument, it is evaluated within the function and y = 10 is not changed in the global environment. Thus, 10 is returned in the last line.\n\nhist() uses the breaks argument to determine where to put the breaks. With the “Sturges” value, it uses the nclass.Sturges method based on Sturges’ 1926 paper on histogram x axis spacing. This value must then be used with range to get the xlim values.\nThis function works due to lazy evaluation and scoping within functions. The x argument does not cause the function to stop since it is not evaluated due to lazy evaluation. Before x is evaluated, stop is reassigned to a function that returns the Sys.time(). Thus when x is printed, x is evaluated as the new function with argument “Error!” so the Sys.time() is returned and thus printed.\n\nFor reference:\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_time &lt;- function(x = stop(\"Error!\")) {\n  stop &lt;- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-08-12 11:59:41 PDT\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#&gt; [1] \"2021-02-21 19:22:36 UTC\"\n```\n:::\n\nI successfully called library() with 0 arguments, thus no arguments are necessary.\n\n6.6.1 Exercises\n\nFor reference:\n\nsum(1, 2, 3)\n\n[1] 6\n\n#&gt; [1] 6\nmean(1, 2, 3)\n\n[1] 1\n\n#&gt; [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n\n[1] 7\n\n#&gt; [1] 7\nmean(1, 2, 3, na.omit = TRUE)\n\n[1] 1\n\n#&gt; [1] 1\n\n\nsum() uses … to get the arguments to be summed. In the first example, thus 1, 2, and 3 sum to 6. In the second example, the name na.omit is irrelevant so 1, 2, 3, and TRUE are summed to 7 since TRUE is coerced to 1 as a numeric.\nmean() take a single vector to calculate the mean of while having a … for arguments to pass through to other methods. Thus only the first argument is taken the mean of. Thus we always get 1 in these scenarios.\n\nThe R documentation at rdrr.io has the documentation for all these arguments.\nThe documentation states that only the lines and points are effected by col, not the labels.\n\n6.7.5 Exercises\n\nload returns a character vector of the names of objects created, invisibly.\nIt returns Null. However, if a filename is not provided, then it will also print the data to the console. It would be useful if it had some message about the success of the writing and perhaps the filename as well.\n\n```{r}\nprint(write.table(matrix(1:10, ncol = 2), file = \"testWT\"))\n```\n\nsource() can only change the wd to that of the file being loaded in, while with_dir() lets the suer specify any wd. Thus with_dir() is more flexible but perhaps more complicated to use.\nAfter a good chunk of searching:\n\nplot_pdf &lt;- function(code) {\n  pdf(\"example.pdf\")\n  on.exit(dev.off(), add = TRUE)\n  code\n}\n\n\nThis should work.\n\n\nprint(capture.output)\n\nfunction (..., file = NULL, append = FALSE, type = c(\"output\", \n    \"message\"), split = FALSE) \n{\n    type &lt;- match.arg(type)\n    rval &lt;- NULL\n    closeit &lt;- TRUE\n    if (is.null(file)) \n        file &lt;- textConnection(\"rval\", \"w\", local = TRUE)\n    else if (is.character(file)) \n        file &lt;- file(file, if (append) \n            \"a\"\n        else \"w\")\n    else if (inherits(file, \"connection\")) {\n        if (!isOpen(file)) \n            open(file, if (append) \n                \"a\"\n            else \"w\")\n        else closeit &lt;- FALSE\n    }\n    else stop(\"'file' must be NULL, a character string or a connection\")\n    sink(file, type = type, split = split)\n    on.exit({\n        sink(type = type, split = split)\n        if (closeit) close(file)\n    })\n    for (i in seq_len(...length())) {\n        out &lt;- withVisible(...elt(i))\n        if (out$visible) \n            print(out$value)\n    }\n    on.exit()\n    sink(type = type, split = split)\n    if (closeit) \n        close(file)\n    if (is.null(rval)) \n        invisible(NULL)\n    else rval\n}\n&lt;bytecode: 0x10aeaad38&gt;\n&lt;environment: namespace:utils&gt;\n\n\n\nNotice that capture.output (which I’ll call 1) features a print statement while capture.output2 (2) does not. We can also see that 2 is a much short function with fewer options via the arguments for how it will work compared to 1. This is a trade off of flexibility vs ease of use.\n6.8.6 Exercises\n\n\n\n\nx &lt;- 1:10\nn &lt;- 3\n\n1 + 2 + 3\n\n[1] 6\n\n1 + (2 + 3)\n\n[1] 6\n\nif (length(x) &lt;= 5) x[[5]] else x[[n]]\n\n[1] 3\n\n#becomes\n\n'+'('+'(1, 2), 3)\n\n[1] 6\n\n'+'(1, '+'(2, 3))\n\n[1] 6\n\n'if'(length(x) &lt;= 5, x[[5]], x[[n]])\n\n[1] 3\n\n\n\nWe are setting x to a call from sample with x = c(1:10, NA), size = 20, and replace = TRUE. Then we set y to a call from runif with 20 observations of a uniformly distributed RV with min 0 and max 1. Finally, we calculate the correlation of x and y using the “kendall” method and all pairwise complete observations.\n\n```{r}\nx &lt;- sample(replace = TRUE, 20, x = c(1:10, NA))\ny &lt;- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)\n```\n\nLets create the version of modify used in the text.\n\n`modify&lt;-` &lt;- function(x, position, value) {\n  x[position] &lt;- value\n  x\n}\n\n\n\n#get(\"x\")[1] &lt;- 10\n#Error in get(\"x\")[1] &lt;- 10 : \n  #target of assignment expands to non-language object\n\nThe above code is what occurs during the function call to modify&lt;-. As can be seen, the same error still occurs, which eliminates the modify function itself as a source of the problem. Based on the error message, this is because get() can not be assigned to.\n\nCreate a replacement function that modifies a random location in a vector.\n\n'rand_mod&lt;-' &lt;- function(x, value){\n    vec_len &lt;- length(x)\n    ind &lt;- round(runif(1, min = 1, max = vec_len), digits = 0)\n    x[ind] &lt;- value\n    return(x)\n}\n\n\n\nvec &lt;- 1:12\nrand_mod(vec) &lt;- 36 \nvec\n\n [1]  1  2  3  4  5  6  7 36  9 10 11 12\n\n\n\nWrite your own version of + that pastes its inputs together if they are character vectors but behaves as usual otherwise.\n\n'%+%' &lt;- function(x, y) {\n    if (is.character(x) && is.character(y)){\n        return( paste0(x, y))\n    }\n    return (x + y)\n}\n\n\n\n1 %+% 2\n\n[1] 3\n\n\"a\" %+% \"b\"\n\n[1] \"ab\"\n\n\n\n\nlibrary(purrr)\nrep_fns &lt;- apropos(\"&lt;-$\", mode = \"function\")\nrep_fns &lt;- rep_fns[rep_fns %in% ls(\"package:base\", all = TRUE)]\nprint(rep_fns)\n\n [1] \".rowNamesDF&lt;-\"    \"[[&lt;-\"             \"[&lt;-\"              \"@&lt;-\"             \n [5] \"&lt;-\"               \"&lt;&lt;-\"              \"$&lt;-\"              \"attr&lt;-\"          \n [9] \"attributes&lt;-\"     \"body&lt;-\"           \"body&lt;-\"           \"class&lt;-\"         \n[13] \"colnames&lt;-\"       \"comment&lt;-\"        \"diag&lt;-\"           \"dim&lt;-\"           \n[17] \"dimnames&lt;-\"       \"Encoding&lt;-\"       \"environment&lt;-\"    \"formals&lt;-\"       \n[21] \"is.na&lt;-\"          \"length&lt;-\"         \"levels&lt;-\"         \"mode&lt;-\"          \n[25] \"mostattributes&lt;-\" \"names&lt;-\"          \"oldClass&lt;-\"       \"parent.env&lt;-\"    \n[29] \"regmatches&lt;-\"     \"row.names&lt;-\"      \"rownames&lt;-\"       \"split&lt;-\"         \n[33] \"storage.mode&lt;-\"   \"substr&lt;-\"         \"substring&lt;-\"      \"units&lt;-\"         \n\nprim_rep_fns &lt;- rep_fns[rep_fns %&gt;%\n    map(get) %&gt;%\n    map_lgl(is.primitive)]\nprint(prim_rep_fns)\n\n [1] \"[[&lt;-\"           \"[&lt;-\"            \"@&lt;-\"            \"&lt;-\"            \n [5] \"&lt;&lt;-\"            \"$&lt;-\"            \"attr&lt;-\"         \"attributes&lt;-\"  \n [9] \"class&lt;-\"        \"dim&lt;-\"          \"dimnames&lt;-\"     \"environment&lt;-\" \n[13] \"length&lt;-\"       \"levels&lt;-\"       \"names&lt;-\"        \"oldClass&lt;-\"    \n[17] \"storage.mode&lt;-\"\n\n\nValid names for a user created infix function is a string matching the regex pattern “^%.*%$”. In other words, initially a % followed by anything then ending with %.\n\n'%^%' &lt;- function(x, y){\nreturn(xor(x, y))\n}\n\nTRUE %^% TRUE\n\n[1] FALSE\n\nT %^% F\n\n[1] TRUE\n\nF %^% T\n\n[1] TRUE\n\nF %^% F\n\n[1] FALSE\n\n\n\n\n\n'%n%' &lt;- function(x, y){\n    return(intersect(x, y))\n}\n\n'%u%' &lt;- function(x, y){\n    return(union(x, y))\n}\n\n'%/%' &lt;- function(x, y){\n    return(setdiff(x, y))\n}"
  },
  {
    "objectID": "Ch3.html",
    "href": "Ch3.html",
    "title": "Chapter 3",
    "section": "",
    "text": "3.2.5 Exercises\n\nTo create a raw scalar, first create a raw vector with the raw(length = 1) function. It then can be filled using indexing and potentially the as.raw() function, which coerces arguments into integers in 8-bit unsigned binary to be compatible with the raw vector.\nTo make a complex scalar, use the complex() constructor and specify the either the real and imaginary components or the modulus and argument of the complex scalar. A complex scalar can also be made using as.complex() but coercing a non-complex value to a complex number does not make much sense or seem realistically useful.\nc(1, FALSE) : 1 0\nc(“a”, 1) : “a” “1”\nc(TRUE, 1L): 1L 1L\n1 == “1” is true because 1 will be coerced into the character “1” when comparing so the values will be equal.\n-1 &lt; FALSE is true since F will be coerced to 0 and -1 &lt; 0.\n“one” &lt; 2 is false since 2 gets converted to “2” which is 50 in decimal ascii. “o” is 111 in ascii so it will be considered greater than “2”\nIn a ceoercion with a logical value and that of another type, it will always be the logical value that is coerced into the other type. This means that NA will not change the type of any data it is present in. If this happened, it could cause issues with the valid data.\nis.atomic() tests for if a vector is of an atomic type (\"logical\", \"integer\", \"numeric\", \"complex\", \"character\" and \"raw\") or null.\nis.numeric() appears to be used in OOP to test if an object is part of class that could be regarded as numeric and has a base value type of double or integer.\nis.vector() tests if its argument is a vector of specified mode (similar to typeof) and has no attributes other than names.\n\n3.3.4 Exercises\n\nsetNames is simply a wrapper function that calls names on the object to set the names to the argument and returns the object. unname is also a wrapper function that sets the names for the object to NULL and returns the object. Both are implemented in R code.\napplying dim() to a 1D vector returns NULL.\nx1, x2, and x3 differ from 1:5 in how the data is interpreted (i.e. its strucutre). Depending on the problem, this difference in structure could have big differences in meaning. x1 is a 3d tensor with 5 “channels” of scalars. x2 is a 3d tensor with 1 row, 5 columns and 1 channel. x3 is a 3d tensor with 5 rows, 1 column and 1 channel.\nAttributes named comment are not printed.\n\n3.4.5 Exercises\n\ntable() returns a contingency table, an object of class \"table\", an array of integer values. Note that unlike S the result is always an array, a 1D array if one factor is given. Table has attributes dim, dimnames, and class. As you tabulate more variables, additional dimensions are added to the table. It appears to be that the number of variables is equal to the number of dimensions.\n\n\n\nf1 &lt;- factor(letters)\nprint(f1)\n\n [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\nlevels(f1) &lt;- rev(levels(f1))\nprint(f1)\n\n [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\nLevels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n\n\nIt appears that changing the levels of a factor also changes the meaning of the data in the vector. This makes sense with how factors are implemented. It seems that the integer data of the factor is unchanged. Thus when the levels data, which maps an integer value to a category, is changed, the category that the factor data corresponds to changes.\n\nI predict that f2 will have the alphabet reversed in the data while in original order in the levels, and f3 will have the data in original order and levels in reverse order. For reference, f1 has data in reverse order and levels in reverse order. Now lets test my predictions.\n\nf2 &lt;- rev(factor(letters))\nprint(f2)\n\n [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\nf3 &lt;- factor(letters, levels = rev(letters))\nprint(f3)\n\n [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\nLevels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n\n\n\nNice!\n3.5.4 Exercises\n\nA vector can only store one type of data; a list can store (pointers to) any type of data. For most data types, a vector stores the data directly itself while a list stores a pointer to the data.\nA list is considered a vector, so as.vector() will not do anything to the list and the list will still not be an atomic vector. Thus, the function unlist() is needed. Demonstration:\n\nlst &lt;- list(1:6)\nis.list(as.vector(lst))\n\n[1] TRUE\n\ntypeof(as.vector(lst))\n\n[1] \"list\"\n\n\nExperimentation:\n\ndt &lt;- Sys.Date()\nDTime &lt;- as.POSIXct(\"2022-11-12\", tz = \"UTC\")\nprint(dt)\n\n[1] \"2024-08-12\"\n\nprint(DTime)\n\n[1] \"2022-11-12 UTC\"\n\nprint(c(dt, DTime))\n\n[1] \"2024-08-12\" \"2022-11-12\"\n\nprint(unlist(list(dt, DTime)))\n\n[1]      19947 1668211200\n\nprint(typeof(c(dt, DTime)))\n\n[1] \"double\"\n\n\n\nUsing c() preserves that the values are dates while unlisting a list loses this information and the data is interpreted as doubles, thus giving the wrong meaning to the data.\n3.6.8 Exercises\n\nZrow &lt;- data.frame(c())\nZcol &lt;- data.frame()\n\n\nprint(Zrow)\n\ndata frame with 0 columns and 0 rows\n\nprint(Zcol)\n\ndata frame with 0 columns and 0 rows\n\n\n\nData frames with zero rows or zero columns appear to be allowed.\n\n\n\n#df2 &lt;- data.frame(1:5, 2:6, row.names = c(\"a\", \"b\", \"a\", \"c\", \"d\"))\n\nDuplicate row names are not allowed and cause an error.\n\n\n\n\ndf &lt;- data.frame(matrix(1:20, nrow = 4, ncol = 5))\nprint(df)\n\n  X1 X2 X3 X4 X5\n1  1  5  9 13 17\n2  2  6 10 14 18\n3  3  7 11 15 19\n4  4  8 12 16 20\n\nprint(paste(\"original is of type\", typeof(df)))\n\n[1] \"original is of type list\"\n\nprint(t(df))\n\n   [,1] [,2] [,3] [,4]\nX1    1    2    3    4\nX2    5    6    7    8\nX3    9   10   11   12\nX4   13   14   15   16\nX5   17   18   19   20\n\nprint(paste(\"transpose is of type \", typeof(t(df))))\n\n[1] \"transpose is of type  integer\"\n\nprint(t(t(df)))\n\n     X1 X2 X3 X4 X5\n[1,]  1  5  9 13 17\n[2,]  2  6 10 14 18\n[3,]  3  7 11 15 19\n[4,]  4  8 12 16 20\n\nprint(paste(\"transpose of transpose is of type \", typeof(t(t(df)))))\n\n[1] \"transpose of transpose is of type  integer\"\n\n\n\ndf &lt;- data.frame(1:26, letters, LETTERS)\nprint(df)\n\n   X1.26 letters LETTERS\n1      1       a       A\n2      2       b       B\n3      3       c       C\n4      4       d       D\n5      5       e       E\n6      6       f       F\n7      7       g       G\n8      8       h       H\n9      9       i       I\n10    10       j       J\n11    11       k       K\n12    12       l       L\n13    13       m       M\n14    14       n       N\n15    15       o       O\n16    16       p       P\n17    17       q       Q\n18    18       r       R\n19    19       s       S\n20    20       t       T\n21    21       u       U\n22    22       v       V\n23    23       w       W\n24    24       x       X\n25    25       y       Y\n26    26       z       Z\n\nprint(paste(\"original is of type\", typeof(df)))\n\n[1] \"original is of type list\"\n\nprint(t(df))\n\n        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]\nX1.26   \" 1\" \" 2\" \" 3\" \" 4\" \" 5\" \" 6\" \" 7\" \" 8\" \" 9\" \"10\"  \"11\"  \"12\"  \"13\" \nletters \"a\"  \"b\"  \"c\"  \"d\"  \"e\"  \"f\"  \"g\"  \"h\"  \"i\"  \"j\"   \"k\"   \"l\"   \"m\"  \nLETTERS \"A\"  \"B\"  \"C\"  \"D\"  \"E\"  \"F\"  \"G\"  \"H\"  \"I\"  \"J\"   \"K\"   \"L\"   \"M\"  \n        [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25]\nX1.26   \"14\"  \"15\"  \"16\"  \"17\"  \"18\"  \"19\"  \"20\"  \"21\"  \"22\"  \"23\"  \"24\"  \"25\" \nletters \"n\"   \"o\"   \"p\"   \"q\"   \"r\"   \"s\"   \"t\"   \"u\"   \"v\"   \"w\"   \"x\"   \"y\"  \nLETTERS \"N\"   \"O\"   \"P\"   \"Q\"   \"R\"   \"S\"   \"T\"   \"U\"   \"V\"   \"W\"   \"X\"   \"Y\"  \n        [,26]\nX1.26   \"26\" \nletters \"z\"  \nLETTERS \"Z\"  \n\nprint(paste(\"transpose is of type \", typeof(t(df))))\n\n[1] \"transpose is of type  character\"\n\nprint(t(t(df)))\n\n      X1.26 letters LETTERS\n [1,] \" 1\"  \"a\"     \"A\"    \n [2,] \" 2\"  \"b\"     \"B\"    \n [3,] \" 3\"  \"c\"     \"C\"    \n [4,] \" 4\"  \"d\"     \"D\"    \n [5,] \" 5\"  \"e\"     \"E\"    \n [6,] \" 6\"  \"f\"     \"F\"    \n [7,] \" 7\"  \"g\"     \"G\"    \n [8,] \" 8\"  \"h\"     \"H\"    \n [9,] \" 9\"  \"i\"     \"I\"    \n[10,] \"10\"  \"j\"     \"J\"    \n[11,] \"11\"  \"k\"     \"K\"    \n[12,] \"12\"  \"l\"     \"L\"    \n[13,] \"13\"  \"m\"     \"M\"    \n[14,] \"14\"  \"n\"     \"N\"    \n[15,] \"15\"  \"o\"     \"O\"    \n[16,] \"16\"  \"p\"     \"P\"    \n[17,] \"17\"  \"q\"     \"Q\"    \n[18,] \"18\"  \"r\"     \"R\"    \n[19,] \"19\"  \"s\"     \"S\"    \n[20,] \"20\"  \"t\"     \"T\"    \n[21,] \"21\"  \"u\"     \"U\"    \n[22,] \"22\"  \"v\"     \"V\"    \n[23,] \"23\"  \"w\"     \"W\"    \n[24,] \"24\"  \"x\"     \"X\"    \n[25,] \"25\"  \"y\"     \"Y\"    \n[26,] \"26\"  \"z\"     \"Z\"    \n\nprint(paste(\"transpose of transpose is of type \", typeof(t(t(df)))))\n\n[1] \"transpose of transpose is of type  character\"\n\n\nIt seems that tranposing a data frame loses the data frame attributes, as the returned object is a matrix containing the underlying data structure for the data frame with the rows and columns transposed properly. If different data types exist in the data frame, columns are coerced so that all the data can be stored in a single vector (matrix since it contains row and column info) with a single type.\n\n\n\n\ndf &lt;- data.frame(matrix(1:20, nrow = 4, ncol = 5))\ndfM &lt;- as.matrix(df)\ndfD &lt;- data.matrix(df)\nprint(dfM)\n\n     X1 X2 X3 X4 X5\n[1,]  1  5  9 13 17\n[2,]  2  6 10 14 18\n[3,]  3  7 11 15 19\n[4,]  4  8 12 16 20\n\nprint(paste(\"as.matrix is of type\", typeof(dfM)))\n\n[1] \"as.matrix is of type integer\"\n\nprint(dfD)\n\n     X1 X2 X3 X4 X5\n[1,]  1  5  9 13 17\n[2,]  2  6 10 14 18\n[3,]  3  7 11 15 19\n[4,]  4  8 12 16 20\n\nprint(paste(\"data.matrix is of type\", typeof(dfD)))\n\n[1] \"data.matrix is of type integer\"\n\n\n\ndf &lt;- data.frame(1:26, letters, LETTERS)\ndfM &lt;- as.matrix(df)\ndfD &lt;- data.matrix(df)\nprint(dfM)\n\n      X1.26 letters LETTERS\n [1,] \" 1\"  \"a\"     \"A\"    \n [2,] \" 2\"  \"b\"     \"B\"    \n [3,] \" 3\"  \"c\"     \"C\"    \n [4,] \" 4\"  \"d\"     \"D\"    \n [5,] \" 5\"  \"e\"     \"E\"    \n [6,] \" 6\"  \"f\"     \"F\"    \n [7,] \" 7\"  \"g\"     \"G\"    \n [8,] \" 8\"  \"h\"     \"H\"    \n [9,] \" 9\"  \"i\"     \"I\"    \n[10,] \"10\"  \"j\"     \"J\"    \n[11,] \"11\"  \"k\"     \"K\"    \n[12,] \"12\"  \"l\"     \"L\"    \n[13,] \"13\"  \"m\"     \"M\"    \n[14,] \"14\"  \"n\"     \"N\"    \n[15,] \"15\"  \"o\"     \"O\"    \n[16,] \"16\"  \"p\"     \"P\"    \n[17,] \"17\"  \"q\"     \"Q\"    \n[18,] \"18\"  \"r\"     \"R\"    \n[19,] \"19\"  \"s\"     \"S\"    \n[20,] \"20\"  \"t\"     \"T\"    \n[21,] \"21\"  \"u\"     \"U\"    \n[22,] \"22\"  \"v\"     \"V\"    \n[23,] \"23\"  \"w\"     \"W\"    \n[24,] \"24\"  \"x\"     \"X\"    \n[25,] \"25\"  \"y\"     \"Y\"    \n[26,] \"26\"  \"z\"     \"Z\"    \n\nprint(paste(\"as.matrix is of type\", typeof(dfM)))\n\n[1] \"as.matrix is of type character\"\n\nprint(dfD)\n\n      X1.26 letters LETTERS\n [1,]     1       1       1\n [2,]     2       2       2\n [3,]     3       3       3\n [4,]     4       4       4\n [5,]     5       5       5\n [6,]     6       6       6\n [7,]     7       7       7\n [8,]     8       8       8\n [9,]     9       9       9\n[10,]    10      10      10\n[11,]    11      11      11\n[12,]    12      12      12\n[13,]    13      13      13\n[14,]    14      14      14\n[15,]    15      15      15\n[16,]    16      16      16\n[17,]    17      17      17\n[18,]    18      18      18\n[19,]    19      19      19\n[20,]    20      20      20\n[21,]    21      21      21\n[22,]    22      22      22\n[23,]    23      23      23\n[24,]    24      24      24\n[25,]    25      25      25\n[26,]    26      26      26\n\nprint(paste(\"data.matrix is of type\", typeof(dfD)))\n\n[1] \"data.matrix is of type integer\"\n\n\nBoth functions coerce inputs into a common type. However, as.matrix follows standard R coercion rules while data.matrix() has different rules to force the matrix type to be numeric. For example, we can see that the letters data was replaced by its factor encoding in order to be numeric."
  },
  {
    "objectID": "Ch18.html",
    "href": "Ch18.html",
    "title": "Chapter 18",
    "section": "",
    "text": "library(rlang)\nlibrary(lobstr)\n\n18.2.4 Exercises\n\n\nast(f(g(h())))\n\n█─f \n└─█─g \n  └─█─h \n\nast(1 + 2 + 3)\n\n█─`+` \n├─█─`+` \n│ ├─1 \n│ └─2 \n└─3 \n\nast((x + y) * z)\n\n█─`*` \n├─█─`(` \n│ └─█─`+` \n│   ├─x \n│   └─y \n└─z \n\n\n\nIn the first example, we are simply using the + infix operator on x and y. In the second, ** is replaced with ‘^’ by the parser according to R documentation. Then standard use of infix operators commences. The third one is an interesting case, since the assignment operator is oriented in reverse of its typical usage. My testing shows that this is legal R syntax. It appears that the parser is simply calling the normal &lt;- and flipping the operands.\nHere ast is generating the syntax tree of the function function, which is notoriously complicated. Here the arguments to the function we are creating are one argument to the function function and the body is another argument to the function function. What makes this special is that ast also has the ability to show the source reference for these function objects; however, it is hidden in this example.\nLets see.\n\nast(if (x &gt; 2){\n    print('hi')\n} else if (x &gt; 0){\n    print('bye')\n} else if (x &lt; -15){\n    print('oops')\n} else {\n    print('ope')\n}\n\n)\n\n█─`if` \n├─█─`&gt;` \n│ ├─x \n│ └─2 \n├─█─`{` \n│ └─█─print \n│   └─\"hi\" \n└─█─`if` \n  ├─█─`&gt;` \n  │ ├─x \n  │ └─0 \n  ├─█─`{` \n  │ └─█─print \n  │   └─\"bye\" \n  └─█─`if` \n    ├─█─`&lt;` \n    │ ├─x \n    │ └─█─`-` \n    │   └─15 \n    ├─█─`{` \n    │ └─█─print \n    │   └─\"oops\" \n    └─█─`{` \n      └─█─print \n        └─\"ope\" \n\n\n\nOne interesting observation is that the else if functions are simply presented as if functions that are an argument of the former if or else if condition. The same is true for the else statement on the last else if condition. This inherently makes sense. I conjecture that the structure of the if function is to have 3 arguments: the boolean condition to evaluate, what to do if the condition is true, and what to do if it is false. The else if statement is logically equivalent to having an if statement only to be run if the previous condition is false. Thus, it makes sense for R to replace else if statements with if statements contingent on the previous if statement being false, since this arrangement is simpler and equivalent to having a separate else if function.\n18.3.5 Exercises\n\nIn the vocabulary introduced in this chapter, an expression can not contain a function, for then it would thus be a call. This prohibits raw and complex vectors from being in expressions, since their creation requires a function. For example, a complex number would require either using the constructor or the sum/difference operator such as a &lt;- 3 + 5i . This is also the reason that it is not possible to create an expression containing a vector of length &gt; 1. Creating such a vector would necessitate the use of a function.\nSubsetting a call object to remove the first element would remove the function name to be called from the object. Since the object still retains the “call” class, I predict that attempting to evaluate it would make R try to call a function with the name of the first argument, which would either fail or result in some other function sharing the same name being called. Now let’s try it.\n\n#eval(expr(read.csv(\"foo.csv\", header = TRUE))[-1])\n#Error in eval(expr(read.csv(\"foo.csv\", header = TRUE))[-1]) : \n  #attempt to apply non-function\n\nWith the structure of the current code, all four lines will evaluate to the same output, since the internal expr wrappers will evaluate to the same arguments with nothing having changed any values. The difference in these 4 lines is when the arguments to call2 are evaluated. As with typical function calls (call2 is itself a function), arguments are evaluated when the function uses them. In this case, call2 uses the arguments when the call2 is called. Thus, arguments passed without expr wrappers will be evaluated so that call2 retains their info in the state those variables were at the time of calling call2. Whereas, with the expr wrapper, the value of the named variable will only be found once the call2 object is evaluated. Thus, changes to the value of “x” or “median” between when the call object is created and when it is evaluated will change the output of these lines.\ncall_standardize struggles with mean since mean uses … so it is not possible to correct arguments, since they may be intended for … usage.\nLets attempt to run this nonsense code\n\n```{r}\nx &lt;- expr(foo(x = 1))\nnames(x) &lt;- c(\"x\", \"y\")\nx\n```\nI see. What is occurring is that x is a call object, which is truly a list. Thus setting names(x) works like it does on a list. As a result, the first object of x is named “x”–which is the value “foo” for the function–and the the second value of x is named “y”–which is the value 1 that corresponds to the argument originally named x. It appears that the name of the argument in the list determines the name of the argument in the call. Hence, we get foo(y = 1) as the argument x is renamed y.\n\n\nx &lt;- 3\nmy_control &lt;- call2(`if`, \n      call2(`&gt;`, x, 1),\n      \"a\",\n      \"b\"\n      )\n\neval(my_control)\n\n[1] \"a\"\n\n\n\nThe code structure is formatted in the same manner as the AST for the way I wrote the call object.\n18.4.4 Exercises\n\n\nprint(ast(f((1))))\n\n█─f \n└─█─`(` \n  └─1 \n\nprint(ast(`(`(1 + 1)))\n\n█─`(` \n└─█─`+` \n  ├─1 \n  └─1 \n\n\n\nR looks for usage of parentheses either as the ( operator or as a general piece of other R syntax. For example, using a ( after a function name does not call the ( function. Examples of each usage can be seen once in both of the above lines of code. In the first line, the outer ( is part of the call to function f, and the inner () is a call to the ( function. In the second line, we are explicitly calling ( function and the inner (1 + 1) is part of scripting for the ( function.\n\n\nast(f(x = 3))\n\n█─f \n└─x = 3 \n\nast((y = 14) )\n\n█─`(` \n└─█─`=` \n  ├─y \n  └─14 \n\n\nI predict that -2^2 will result in -4 since ^ has higher precedence than -. Thus 2^2 will be evaluated before the negation is applied. Test:\n\n-2^2\n\n[1] -4\n\n\n\nNice!\n\nBoolean mathematics would suggest that !1 + !1 is 0 (~T or ~T = F or F = F). However, this is confusing in R since ! has lower priority than +.\n\nprint(!1 + !1)\n\n[1] FALSE\n\nprint(ast(!1 + !1))\n\n█─`!` \n└─█─`+` \n  ├─1 \n  └─█─`!` \n    └─1 \n\n\n\nNow I understand how R would apply these rules. This value is due to R casting integers to boolean values and the order of operations. We can see in the ast that R evaluates this expression as !(T or F) which is F.\n\nx1 &lt;- x2 &lt;- x3 &lt;- 0 works because, as mentioned in the book, assignment in R is evaluated from right to left and the &lt;- operator returns the value assigned.\n\nprint(ast(x + y %+% z))\n\n█─`+` \n├─x \n└─█─`%+%` \n  ├─y \n  └─z \n\nprint(ast(x ^ y %+% z))\n\n█─`%+%` \n├─█─`^` \n│ ├─x \n│ └─y \n└─z \n\n\n\nThe precedence of custom infill operator depends on the other operators also present in the expression. The R help guide shows custom infix operators has having lower precedence than ^ but higher precedence than addition (+). This agrees with the ASTs we’ve observed.\n\nAn error results.\n\n```{r}\n#parse_expr(\"x + 1; y + 1\")\n```\n\nErrors result in both cases.\n\n```{r}\n#parse_expr(\"a +\")\n#parse_expr(\"f())\")\n```\n\n\nexpr &lt;- expr(g(a + b + c + d + e + f + g + h + i + j + k + l + \n  m + n + o + p + q + r + s + t + u + v + w + x + y + z))\n\nexpr_text(expr)\n\n[1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + \\n    p + q + r + s + t + u + v + w + x + y + z)\"\n\n\n\nexpr_text() returns the initial text we supplied to expr().\n18.5.3 Exercises\n\n\nexpr_type &lt;- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\n\nswitch_expr &lt;- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \", typeof(x), call. = FALSE)\n  )\n}\n\nlogical_abbr_rec &lt;- function(x) {\n  switch_expr(x,\n    # Base cases\n    constant = FALSE,\n    symbol = as_string(x) %in% c(\"F\", \"T\"),\n\n    # Recursive cases\n    call = purrr::some(x[-1], logical_abbr_rec),\n    pairlist = purrr::some(x, logical_abbr_rec)\n  )\n}\n\nlogical_abbr &lt;- function(x) {\n  logical_abbr_rec(enexpr(x))\n}\n\nprint(logical_abbr(mean(x, na.rm = T)))\n\n[1] TRUE\n\n#&gt; [1] TRUE\nprint(logical_abbr(function(x, na.rm = T) FALSE))\n\n[1] TRUE\n\n#&gt; [1] TRUE\nprint(logical_abbr(T(3, 4)))\n\n[1] FALSE\n\n\n\nlibrary(purrr)\n\n\nAttaching package: 'purrr'\n\n\nThe following objects are masked from 'package:rlang':\n\n    %@%, flatten, flatten_chr, flatten_dbl, flatten_int, flatten_lgl,\n    flatten_raw, invoke, splice\n\nlogical_abbr_fn &lt;- function(fn){\n    return(any(c(formals(fn), body(fn)) %&gt;%\n                   purrr::map_lgl(logical_abbr)\n               ))\n}\nprint(logical_abbr_fn(function(x = TRUE) {\n  g(x + T)\n}))\n\n[1] TRUE\n\nprint(logical_abbr_fn(function(x = TRUE) {\n  g(x + FALSE)\n}))\n\n[1] FALSE\n\n\n\nflat_map_chr &lt;- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\nfind_assign_rec &lt;- function(x) {\n  switch_expr(x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(as.list(x), find_assign_rec),\n    call = {\n      if (any(grepl(\"&lt;-\", x[[1]]))) {\n        ind &lt;-  (is_call(x[[2]]))\n        as_string(x[[2 + ind]])\n      } else {\n        flat_map_chr(as.list(x), find_assign_rec)\n      }\n    }\n  )\n}\n\nfind_assign &lt;- function(x) find_assign_rec(enexpr(x))\n\nprint(find_assign({names(x) &lt;- y}))\n\n[1] \"y\"\n\nfind_assign(a &lt;- b &lt;- c &lt;- 1)\n\n[1] \"a\"\n\n\n\ncall_to_fn_rec &lt;- function(x, fn) {\n  switch_expr(x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(as.list(x), call_to_fn_rec, fn = fn),\n    call = {\n      if (any(grepl(fn, x[[1]]))) {\n        ind &lt;-  (is_call(x[[2]]))\n        as_string(x[[2 + ind]])\n      } else {\n        flat_map_chr(as.list(x), call_to_fn_rec, fn = fn)\n      }\n    }\n  )\n}\n\ncall_to_fn &lt;- function(x, fn) call_to_fn_rec(enexpr(x), fn)"
  },
  {
    "objectID": "Ch20.html",
    "href": "Ch20.html",
    "title": "Chapter 20",
    "section": "",
    "text": "library(rlang)\nlibrary(purrr)\n\n\nAttaching package: 'purrr'\n\n\nThe following objects are masked from 'package:rlang':\n\n    %@%, flatten, flatten_chr, flatten_dbl, flatten_int, flatten_lgl,\n    flatten_raw, invoke, splice\n\n\n20.2.4 Exercises\n\nBy default, source uses the global env. local = TRUE makes source use the env from which source was called. You can also provide the env for source to use via the local parameter.\nI predict the first two lines will result in 4 and the last line will result in expr(4).\n\nprint(eval(expr(eval(expr(eval(expr(2 + 2)))))))\n\n[1] 4\n\nprint(eval(eval(expr(eval(expr(eval(expr(2 + 2))))))))\n\n[1] 4\n\nprint(expr(eval(expr(eval(expr(eval(expr(2 + 2))))))))\n\neval(expr(eval(expr(eval(expr(2 + 2))))))\n\n\n\n# name is a string\nget2 &lt;- function(name, env = caller_env()) {\n    eval(sym(name), env)\n}\nassign2 &lt;- function(name, value, env = caller_env()) {\n    eval(expr(!!sym(name) &lt;- !! value), env)\n}\nx &lt;- 4\nprint(get2(\"x\"))\n\n[1] 4\n\nassign2(\"beep\", 6)\nbeep\n\n[1] 6\n\n\n\nsource2 &lt;- function(path, env = caller_env()) {\n  file &lt;- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs &lt;- parse_exprs(file)\n\n  res &lt;- exprs %&gt;%\n      purrr::map(eval, envir = env)\n\n  invisible(res)\n}\n\nThe first line of local3 generates a call object with appropriate handling of the promises expr and envir. The second line evaluates this call in the parent environment.\n\n20.3.6 Exercises\n\nI predict that eval(q1) will return 1, eval(q2) will be 11, and eval(q3) will return 111. Lets test my predictions.\n\n```{r}\nq1 &lt;- new_quosure(expr(x), env(x = 1))\nq1\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x\n#&gt; env:  0x7fac62d19130\n\nq2 &lt;- new_quosure(expr(x + !!q1), env(x = 10))\nq2\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x + (^x)\n#&gt; env:  0x7fac62e35a98\n\nq3 &lt;- new_quosure(expr(x + !!q2), env(x = 100))\nq3\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x + (^x + (^x))\n#&gt; env:  0x7fac6302feb0\nprint(eval_tidy(q1))\nprint(eval_tidy(q2))\nprint(eval_tidy(q3))\n```\nNice!\n\n\nenenv &lt;- function(arg1){\n    return(get_env(enquo(arg1)))\n}\n\n\n20.4.6 Exercises\n\n\ntransform2 &lt;- function(.data, ...) {\n  dots &lt;- enquos(...)\n\n  for (i in seq_along(dots)) {\n    name &lt;- names(dots)[[i]]\n    dot &lt;- dots[[i]]\n\n    .data[[name]] &lt;- eval_tidy(dot, .data)\n  }\n\n  .data\n}\n\n\ndf &lt;- data.frame(x = 1:5, y = 6:2)\nprint(transform2(df, x = x * 2, x = x * 2))\n\n   x y\n1  4 6\n2  8 5\n3 12 4\n4 16 3\n5 20 2\n\n\n\n\nprint(purrr::map)\n\nfunction (.x, .f, ..., .progress = FALSE) \n{\n    map_(\"list\", .x, .f, ..., .progress = .progress)\n}\n&lt;bytecode: 0x116d2e070&gt;\n&lt;environment: namespace:purrr&gt;\n\n\nI am unable to see exactly how map works which limits my ability to understand what map’s limitations are. However, I assume that map may use parallel computation to speed up. This would limit its ability to do computations where a certain column is defined by another previous column from the transformation. We can see that transform2 works this way due to its sequential computation and experimental evidence from the prompt in Hadley’s book.\n\n\nsubset2 &lt;- function(data, rows) {\n  rows &lt;- enquo(rows)\n  rows_val &lt;- eval_tidy(rows, data)\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}\n\nsubset3 &lt;- function(data, rows) {\n  rows &lt;- enquo(rows)\n  eval_tidy(expr(data[!!rows, , drop = FALSE]), data = data)\n}\n\ndf &lt;- data.frame(x = 1:3)\nsubset3(df, x &gt; 1)\n\n  x\n2 2\n3 3\n\n\n\nThe difference is in the evaluation of the rows argument. In subset2, rows is evaluated by eval_tidy using the data as the env. In subset3, rows is unqouted using !! and evaluated simultaneously to the subsetting. Both steps use the data mask, which could cause incorrect evaluation if the wrong variable is found. For example, this could occur if the data mask has an object named data, as the program would use data from the data mask rather than data the function argument. This could result in error due to attempting to subset something not subsettable.\n\n\narrange2 &lt;- function(.df, ..., .na.last = TRUE) {\n    # enclose the arguments containing the columns to sort by\n    args &lt;- enquos(...)\n  # place the columns to sort by into order to use for sorting and .na.last for how to handle NAs. Create expr\n  order_call &lt;- expr(order(!!!args, na.last = !!.na.last))\n  # evaluate expr with the df as the data mask, so the columns to sort by can be found to sort by\n  ord &lt;- eval_tidy(order_call, .df)\n  #error checking\n  stopifnot(length(ord) == nrow(.df))\n    # use the permutation from ord to sort .df as wanted\n  .df[ord, , drop = FALSE]\n}\n\n\nIf the !! was omitted on .na.last, we would have na.last = .na.last. .na.last would be evaluated when order needs it during the following line. It is unlikely to have a variable named .na.last inside of .df, so the value of .na.last would be looked for from the calling env of order, which is the env of arrange2. This environment contains the correct value of .na.last, so the correct value would be found.\n20.5.4 Exercises\n\nThe primary difference is the use of the $ operator rather than [[. This approach evaluates the symbol var and accesses the dataframe using $. This ensures that we get only results from the data frame itself (during tidy_eval evaluation) without risk of pulling the wrong variable from the environment. Overall, the functions should be equivalent from the users point of view and I do not see anything that makes it harder.\n\n20.6.3 Exercises\n\n\ndata(mtcars)\n#head(mtcars)\nlm3a &lt;- function(formula, data) {\n  formula &lt;- enexpr(formula)\n\n  lm_call &lt;- expr(lm(!!formula, data = data))\n  eval(lm_call, caller_env())\n}\n#lm3a(mpg ~ disp, mtcars)\n\n\nThis function fails due to lm_call being evaluated in the wrong environment, where the correct data can not be found. In depth, lm_call is evaluated in the caller_env(), which is the global env in this example. Thus eval is finding the function utils::data when it searches for the data object, since the data object we want is defined in the function’s execution env and not the global env. Hence, the code is attempting to fit a linear model to data that is actually a function, triggering failures in lm checks for obvious reasons.\n\n\nlm_try_diff_preds &lt;- function(resp, data){\n    resp &lt;- enexpr(resp)\n    data &lt;- enexpr(data)\n    helper &lt;- function(pred){\n        pred &lt;- enexpr(pred)\n        lm_call &lt;- expr(lm(!!resp ~ !!pred, data = !!data))\n        eval(lm_call, caller_env())\n    }\n    return(helper)\n}\nmy_lm_h &lt;- lm_try_diff_preds(mpg, data = mtcars)\nprint(my_lm_h(disp))\n\n\nCall:\nlm(formula = mpg ~ disp, data = mtcars)\n\nCoefficients:\n(Intercept)         disp  \n   29.59985     -0.04122  \n\nprint(my_lm_h(I(1/disp)))\n\n\nCall:\nlm(formula = mpg ~ I(1/disp), data = mtcars)\n\nCoefficients:\n(Intercept)    I(1/disp)  \n      10.75      1557.67  \n\nprint(my_lm_h(disp * cyl))\n\n\nCall:\nlm(formula = mpg ~ disp * cyl, data = mtcars)\n\nCoefficients:\n(Intercept)         disp          cyl     disp:cyl  \n   49.03721     -0.14553     -3.40524      0.01585  \n\n\n\nNice!\n\n\nresample_lm &lt;- function(formula, data,\n                        rs_data = data[sample(nrow(data), replace = TRUE), , drop = FALSE],\n                        env = caller_env()){\n    formula &lt;- enexpr(formula)\n    lm_call &lt;- expr(lm(!!formula, ))\n}"
  },
  {
    "objectID": "CH2.html",
    "href": "CH2.html",
    "title": "Chapter 2",
    "section": "",
    "text": "Exercises 2.2.2:\n\nThe variables a, b, and c will all refer to the same object in memory. In other terms, a, b, and c are aliases for the same object. d will point to a different object at a different place in memory. However, the contents of the object pointed to by d will be equal to the contents of the object pointed to by a, b, c.\n\n\n\nprint(lobstr::obj_addr(mean))\n\n[1] \"0x12190e158\"\n\nprint(lobstr::obj_addr(base::mean))\n\n[1] \"0x12190e158\"\n\nprint(lobstr::obj_addr(get(\"mean\")))\n\n[1] \"0x12190e158\"\n\nprint(lobstr::obj_addr(evalq(mean)))\n\n[1] \"0x12190e158\"\n\nprint(lobstr::obj_addr(match.fun(\"mean\")))\n\n[1] \"0x12190e158\"\n\n\nYes, the different methods of accessing the mean function all point to the same underlying object.\n\nAutomatic conversion could cause an issue if the new, changed variable names are significantly different from the original names and a data analyst now can not find the column name easily or existing code for that column name is now nonfunctional. Perhaps the syntactically invalid portion of the name carries information about the data that will be lost with automatic correction. This behavior can be enabled or disabled by the check.names argument.\nThe character \"X\" is prepended if necessary. All invalid characters are translated to \".\". A missing value is translated to \"NA\". Names which match R keywords have a dot appended to them. Duplicated values are altered by make.unique.\nThe textbook did not mention that syntactic names can not start with a dot followed by a number. Thus, “.123e1” is not syntactic.\n\n2.3.6 Exercises\n\ntracemem(1:10) is not useful since the vector 1:10 is not referred to by any variable accessible in our environment. Thus, we will not make any changes to the vector, which defeats the point of tracking changes to the vector in memory.\n\nx &lt;- c(1L, 2L, 3L)\nprint(typeof(x))\n\n[1] \"integer\"\n\ntracemem(x)\n\n[1] \"&lt;0x1072fa388&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x1072fa388 -&gt; 0x1073ebfc8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers withCallingHandlers handle_error process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x1073ebfc8 -&gt; 0x10740e418]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers withCallingHandlers handle_error process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\nprint(typeof(x))\n\n[1] \"double\"\n\n\n\nR must make a copy of the vector since the vector was initialized for integers while one of the values is being replaced with a numeric value (float). Since R vectors must be of the same type, R must convert the vector to being numeric when inserting the 4. Additionally, the R double type use twice the memory allocation as integers so the double 4 would not fit in the vector anyways (if I make assumptions about the working of R vectors in memory).\n\na —————–&gt; 1:10 &lt;—\n\n_____—|^ l\nb —&gt; | ‘^ |’ ^ | l\nl^ l———- ^\nc —&gt; | ’ | ’^ |. -|—————-&gt; 1:10\n\n\n\nSolutions On Paper\n\n\n2.4.1 Exercises\n\nobject.size() believes that y has 100 copies of the list, while obj_size() recognizes that y only has 100 references to the same list. Thus, object.size() estimates the size of y to be approximately 100 times that of obj_size().\nThe size of obj_size(funs) is rather misleading since the environment would always contain the base functions mean, sd, and var regardless of whether funs existed. Since most the the memory listed as being for funs is used to store these functions, the marginal memory use of having funs is much smaller than obj_size() makes it appear.\n8000000 B\n8000016 B\n8000016 B\n16000016 B\n16000016 B\n16000016 B\n24000016 B\n\n2.5.3 Exersizes\n\nA circular list is not created because the list x is copied when the list x is added to itself.\n\n\n\nmed1 &lt;- function(x){\n    medians &lt;- vapply(x, median, numeric(1))\n\n    for (i in seq_along(medians)) {\n      x[[i]] &lt;- x[[i]] - medians[[i]]\n    }\n    return(x)\n}\nmed2 &lt;- function(x){\n    medians &lt;- vapply(x, median, numeric(1))\n    nCols &lt;- ncol(x)\n    y &lt;- as.list(x)\n\n  \n    for (i in 1:nCols) {\n      y[[i]] &lt;- y[[i]] - medians[[i]]\n    }\n    return(as.data.frame(y))\n}\n\n\nmake_df &lt;-  function(cols){\n    return(data.frame(matrix(runif(cols * 1e4), ncol = cols)))\n}\n\nresults &lt;- bench::press(\n    cols = seq(1, 500, by = 50),\n    {\n        expX &lt;- make_df(cols)\n        bench::mark(\n            first = med1(expX),\n            second = med2(expX)\n        )\n    }\n)\n\nRunning with:\n    cols\n\n\n 1     1\n\n\n 2    51\n\n\n 3   101\n\n\n 4   151\n\n\n 5   201\n\n\n 6   251\n\n\n 7   301\n\n\n 8   351\n\n\n 9   401\n\n\n10   451\n\n\n\nprint(results)\n\n# A tibble: 20 × 14\n   expression  cols      min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc\n   &lt;bch:expr&gt; &lt;dbl&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;\n 1 first          1 112.09µs 129.48µs    7549.      389KB     33.0  3200    14\n 2 second         1  157.6µs 175.66µs    5633.    301.9KB     25.7  2630    12\n 3 first         51    7.5ms   7.91ms     127.     11.7MB     99.7    33    26\n 4 second        51   7.77ms   8.21ms     122.     11.7MB     77.6    36    23\n 5 first        101  15.39ms  15.65ms      63.8    23.3MB    357.      5    28\n 6 second       101  16.25ms  16.48ms      60.8    23.2MB    105.     11    19\n 7 first        151  23.75ms  24.16ms      41.5      35MB    291.      3    21\n 8 second       151  24.24ms   24.6ms      40.6    34.6MB    122.      5    15\n 9 first        201   30.8ms  31.45ms      31.8    46.7MB    207.      2    13\n10 second       201  32.11ms   33.1ms      30.4    46.1MB     60.8     5    10\n11 first        251  40.13ms  40.59ms      24.6    58.5MB    123.      2    10\n12 second       251  41.76ms  42.09ms      23.8    57.6MB     71.4     3     9\n13 first        301   47.2ms   47.9ms      20.9    70.4MB     93.9     2     9\n14 second       301  48.83ms  49.26ms      20.3      69MB     30.5     4     6\n15 first        351  55.11ms  56.17ms      17.9    82.3MB     35.8     3     6\n16 second       351  56.25ms  58.14ms      17.4    80.5MB     34.7     3     6\n17 first        401  61.53ms  62.51ms      16.1    94.4MB     26.8     3     5\n18 second       401  68.58ms  68.58ms      14.6      92MB    102.      1     7\n19 first        451  71.71ms  74.83ms      13.5   106.5MB     18.1     3     4\n20 second       451  74.18ms  75.91ms      13.2   103.4MB     32.9     2     5\n# ℹ 5 more variables: total_time &lt;bch:tm&gt;, result &lt;list&gt;, memory &lt;list&gt;,\n#   time &lt;list&gt;, gc &lt;list&gt;\n\n\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nresults %&gt;%\n  unnest(c(time, gc)) %&gt;%\n  filter(gc == \"none\") %&gt;%\n  mutate(expression = as.character(expression)) %&gt;%\n  ggplot(aes(x = cols, y = median, color = expression)) +\n  geom_point() + geom_line() \n\n\n\n\n\n\n\n\nI surprisingly find that both median subtracting functions have very similar median runtimes. For both functions, runtime appears to grow O(logn) with the number of cols.\n\nLets try and see.\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\n#tracemem(e1)\ne2 &lt;- e1\ne1$c = 8\n\n\nAn error results if tracemem is used on an environment."
  },
  {
    "objectID": "Ch7.html",
    "href": "Ch7.html",
    "title": "Chapter 7",
    "section": "",
    "text": "7.2.7 Exercises\n\nLists often copy on modification, environments do not. Environments have parents, while lists do not. List elements are ordered while environment elements are not.\n\nlibrary(rlang)\ne1 &lt;- env()\ne1$loop &lt;- e1\n\n\ne2 &lt;- env()\ne3 &lt;- env(dedoop = e2)\ne2$loop &lt;- e3\nenv_print(e2)\n\n&lt;environment: 0x13ce9f0a8&gt;\nParent: &lt;environment: global&gt;\nBindings:\n• loop: &lt;env&gt;\n\nenv_print(e3)\n\n&lt;environment: 0x13ceee890&gt;\nParent: &lt;environment: global&gt;\nBindings:\n• dedoop: &lt;env&gt;\n\n\ne[[1]] does not make sense because environments are not ordered, so there is no way to refer to elements by indexing. In a workflow using environments, it generally does not make sense to grab multiple elements at once like e[c(“a”, “b”)] attempts to do.\n\nmy_env_poke &lt;- function(env = caller_env(), name, value){\n    if (!exists(name, envir = env, inherits = FALSE)){\n        env_poke(env, name , value)\n        return(value)\n    }\n    print(\"Name already exists\")\n    return(-1)\n\n}\n\n\n\n#test it out\nmy_env_poke(e1, \"loop\", 2)\n\n[1] \"Name already exists\"\n\n\n[1] -1\n\nmy_env_poke(e1, \"a\", 4)\n\n[1] 4\n\ne1$a\n\n[1] 4\n\n\n\nIf the provided environment is the empty environment, it will error. If the provided environment has a binding under the provided name, it will write the variable to the provided value in the provided env only. If the provided env does not have the relevant variable, then rebind will recursively call itself with the parent of the provided environment. In total, this function will recursively look for the first environment that has the variable name and rewrite the value. If no environment has the value, it will error. This differs from &lt;&lt;- with regards to that &lt;&lt;- will create a binding in the global env if no prior checked env has the binding. rebind may be preferable since it will not create new bindings in higher level environments, which can create errors and be difficult to debug.\n\n7.3.1 Exercises\n\nModify where() to return all environments that contain a binding for name.\nExperimentation implies that environments ought to be concatenated in a list.\n\nlibrary(magrittr)\n\n\nAttaching package: 'magrittr'\n\n\nThe following object is masked from 'package:rlang':\n\n    set_names\n\nmy_where &lt;- function(name, env = caller_env()){\n    result &lt;- vector(\"list\", env_depth(env))\n    i &lt;- 1\n    while (!identical(env, empty_env())){\n        if (env_has(env, name)){\n            result[[i]] &lt;- env\n        }\n        env &lt;- env_parent(env)\n        i &lt;- i + 1\n    }\n\n    return(Filter(Negate(is.null), result))\n}\n\n\n\ne1a &lt;- env(empty_env(), a = 1, b = 2)\ne1b &lt;- env(e1a, b = 10, c = 11)\ne1c &lt;- env(e1b, a = 12, d = 13)\n\nmy_where(\"a\", e1c)\n\n[[1]]\n&lt;environment: 0x1398acac8&gt;\n\n[[2]]\n&lt;environment: 0x1397fc320&gt;\n\n\n\nWrite a function called fget() that finds only function objects. It should have two arguments, name and env, and should obey the regular scoping rules for functions: if there’s an object with a matching name that’s not a function, look in the parent. For an added challenge, also add an inherits argument which controls whether the function recurses up the parents or only looks in one environment.\n\nfget &lt;- function(name, env = caller_env(), inherits = TRUE){\n    if (!inherits){\n        if(is.function(env[[name]])){\n            return (env[[name]])\n        } \n        stop(\"Can't find \", name, call. = FALSE)\n    }\n    while (!identical(env, empty_env())){\n        if(is.function(env[[name]])){\n            return (env[[name]])\n        } \n        env &lt;- env_parent(env)\n    }\n    stop(\"Can't find \", name, call. = FALSE)\n}\n\n\n\nmean &lt;- 10\nfget(\"mean\", inherits = TRUE)\n\nfunction (x, ...) \nUseMethod(\"mean\")\n&lt;bytecode: 0x12e0e02b0&gt;\n&lt;environment: namespace:base&gt;\n\n\n7.4.5 Exercises\n\nsearch_envs() will include the current environment and will not include the empty environment. env_parents(global_env()) will include the empty environment and will not inlcude the base environment. If search_envs() is called from an environment other than the base environment, there will also be differences due to more or less environments being part of the search path. env_parents(global_env()) also seems to include more meta-data about the envs, albeit in a less easy to read manner.\n\n\n\nSolution On Paper\n\n\n\nlibrary(rlang)\nadv_str &lt;- function(func, env = caller_env()){\n    #env &lt;- caller_env()\n    def_env &lt;- fn_env(func)\n    while (!identical(env, empty_env())){\n        if (env_has(env, func, inherit = FALSE)){\n            if (is.function(env[[func]])){\n                res = list(Closed_Environment = def_env, Found_In_env = env)\n\n                return(res)\n            }\n        }\n        env &lt;- env_parent(env)\n    }\n    stop(\"Can't find \", name, call. = FALSE)\n}\n\n\n7.5.5 Exercises\n\n\ncall_ls &lt;- function(){\n    return (ls(envir = caller_env(), all.names = TRUE))\n}"
  },
  {
    "objectID": "Ch4.html",
    "href": "Ch4.html",
    "title": "Chapter 4",
    "section": "",
    "text": "4.2.6 Exercises\n\na\n\nmtcars[mtcars$cyl == 4, ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[-(1:4), ]\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[mtcars$cyl &lt;= 5, ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nmtcars[mtcars$cyl %in% c(4,6), ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nValiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\n2.\n\nx &lt;- 1:5\nx[NA]\n\n[1] NA NA NA NA NA\n\n\n\nNA always selects an element and replaces the value with NA, due to reasons of being unknown. As a length 1 vector, this NA value is recycled to all 5 elements of x. Thus all elements are chosen with NA replacements.\n\n\nx &lt;- outer(1:5, 1:5, FUN = \"*\")\nx\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    2    4    6    8   10\n[3,]    3    6    9   12   15\n[4,]    4    8   12   16   20\n[5,]    5   10   15   20   25\n\nx[upper.tri(x)]\n\n [1]  2  3  6  4  8 12  5 10 15 20\n\nis.matrix(x[upper.tri(x)])\n\n[1] FALSE\n\n\n\nupper.tri() returns a logical matrix that contains TRUE values in the upper triangular section and FALSE elsewhere. Subsetting a matrix with it returns a vector containing the upper triangular values of the matrix in column major order. The functionality appears to be consistent with other methods of subsetting a matrix with regards to the fact that a vector is returned.\n\n\nmtcars\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\nmtcars[1:20] errors since this is attempting to select columns 1 thru 20, which do not exist since mtcars only has 11 columns. While mtcars[1:20,] is accessing the first 20 rows, which do exist. Thus, the code works.\n\ngetDiag &lt;- function(m){\n    upper &lt;- upper.tri(m)\n    lower &lt;- lower.tri(m)\n    diagB &lt;- !(upper | lower)\n    return(m[diagB])\n    }\n\n\n\nx &lt;- outer(1:5, 1:5, FUN = \"*\")\ngetDiag(x)\n\n[1]  1  4  9 16 25\n\n\n\ndf[is.na(df)] &lt;- 0 should replace all na values with 0. is.na(df) returns the location of na values and the subsetting thus replaces them with 0.\n\n4.3.5 Exercises\n\nmtcars$cyl[[3]]\nmtcars$cyl[3]\nmtcars[[‘cyl’]][[3]]\nmtcars[[‘cyl’]][3]\nmtcars[‘cyl’][[3]]\nmtcars[‘cyl’][3]\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\n\n\n\ndf.residual(mod)\n\n[1] 30\n\n\n\nsummary(mod)$r.squared\n\n[1] 0.7528328\n\n\n4.5.9 Exercises\n\n\ndf &lt;- data.frame(outer(1:5, 1:5, FUN = paste, sep = \",\"))\nstr(df)\n\n'data.frame':   5 obs. of  5 variables:\n $ X1: chr  \"1,1\" \"2,1\" \"3,1\" \"4,1\" ...\n $ X2: chr  \"1,2\" \"2,2\" \"3,2\" \"4,2\" ...\n $ X3: chr  \"1,3\" \"2,3\" \"3,3\" \"4,3\" ...\n $ X4: chr  \"1,4\" \"2,4\" \"3,4\" \"4,4\" ...\n $ X5: chr  \"1,5\" \"2,5\" \"3,5\" \"4,5\" ...\n\n#to permute the columns\ncolPer &lt;- df[sample(1:5, 5)]\nstr(colPer)\n\n'data.frame':   5 obs. of  5 variables:\n $ X1: chr  \"1,1\" \"2,1\" \"3,1\" \"4,1\" ...\n $ X2: chr  \"1,2\" \"2,2\" \"3,2\" \"4,2\" ...\n $ X3: chr  \"1,3\" \"2,3\" \"3,3\" \"4,3\" ...\n $ X4: chr  \"1,4\" \"2,4\" \"3,4\" \"4,4\" ...\n $ X5: chr  \"1,5\" \"2,5\" \"3,5\" \"4,5\" ...\n\n#rows and cols\nrcPer &lt;- df[sample(1:5, 5), sample(1:5, 5)]\nstr(rcPer)\n\n'data.frame':   5 obs. of  5 variables:\n $ X5: chr  \"5,5\" \"1,5\" \"2,5\" \"3,5\" ...\n $ X4: chr  \"5,4\" \"1,4\" \"2,4\" \"3,4\" ...\n $ X2: chr  \"5,2\" \"1,2\" \"2,2\" \"3,2\" ...\n $ X1: chr  \"5,1\" \"1,1\" \"2,1\" \"3,1\" ...\n $ X3: chr  \"5,3\" \"1,3\" \"2,3\" \"3,3\" ...\n\n\n\nYes, it appears that both rows and columns can be permuted in one step.\n\nI would use df[sample(1:nrow(df), m), ]\nI am still unsure what is meant that the sample must be “contiguous”.\n\ndf2 &lt;- setNames(df, c('q', \"a\", \"d\", \"f\", \"c\"))\nprint(df2)\n\n    q   a   d   f   c\n1 1,1 1,2 1,3 1,4 1,5\n2 2,1 2,2 2,3 2,4 2,5\n3 3,1 3,2 3,3 3,4 3,5\n4 4,1 4,2 4,3 4,4 4,5\n5 5,1 5,2 5,3 5,4 5,5\n\nalphDf &lt;- df2[,order(names(df2))]\nalphDf\n\n    a   c   d   f   q\n1 1,2 1,5 1,3 1,4 1,1\n2 2,2 2,5 2,3 2,4 2,1\n3 3,2 3,5 3,3 3,4 3,1\n4 4,2 4,5 4,3 4,4 4,1\n5 5,2 5,5 5,3 5,4 5,1\n\nprint(alphDf)\n\n    a   c   d   f   q\n1 1,2 1,5 1,3 1,4 1,1\n2 2,2 2,5 2,3 2,4 2,1\n3 3,2 3,5 3,3 3,4 3,1\n4 4,2 4,5 4,3 4,4 4,1\n5 5,2 5,5 5,3 5,4 5,1"
  },
  {
    "objectID": "Ch5.html",
    "href": "Ch5.html",
    "title": "Chapter 5",
    "section": "",
    "text": "5.2.4 Exercises\n\nThe code lines will have the following return types:\nifelse(TRUE, 1, “no”) — 1 (double)\nifelse(FALSE, 1 “no”) — “no” (chr)\nifelse(NA, 1, “no”) — NA\nFirst, it is determined what values are taken from the yes and no vectors. Then the answers will be coerced based on R coercion rules so that all selected values can be accommodated.\n\nx &lt;- 1:10\nif (length(x)) \"not empty\" else \"empty\"\n\n[1] \"not empty\"\n\n#&gt; [1] \"not empty\"\n\nx &lt;- numeric()\nif (length(x)) \"not empty\" else \"empty\"\n\n[1] \"empty\"\n\n#&gt; [1] \"empty\"\n\nThe code works due to R’s rules for evaluating True and False values. Numberical values other than 0 are True when treated as logical values and 0 is False, similar to most other programming languages. In the first example, length(x) is 10, thus the condition is true. In the second example, length(x) is 0 since x is empty, this the condition is False. This chunk of code will work for any vector x due to R’s conversion of numerical values into logical values since only empty vectors will have zero length–giving the “empty” result–and non-empty vectors will have non-zero length, giving the “not empty” return value.\n\n5.3.3 Exercises\n\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\nfor (i in 1:length(x)) {\n  out[i] &lt;- x[i] ^ 2\n}\nout\n\n[[1]]\n[1] NA\n\n\n\nThis code works because numeric types return NA if the index is greater than their length. I.e. if x is of numeric type, x[i] returns NA if i &gt; length(x).\n\n\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n}\nxs\n\n[1] 1 2 3 2 4 6\n\n\n\nOne interesting observation in this example is that we do not get infinite iteration over xs due to xs being lengthened during each iteration. Also, it is possible that xs is being copied (i.e. its memory location is changing) during the iterations. It seems that when the loop initially begins, R grabs the contents of xs in the seperate copy that is then iterated ove during the loop to avoid this issue. xs then is then being reassigned to a new vector throughout the iterations. i.e. The state of the vector xs upon the first entry of the loop is being held constant.\n\n\nfor (i in 1:3) {\n  i &lt;- i * 2\n  print(i) \n}\n\n[1] 2\n[1] 4\n[1] 6\n\n#&gt; [1] 2\n#&gt; [1] 4\n#&gt; [1] 6\n\n\nIt appears that i is reassigned to the next value in 1:3 at the beginning of each iteration of the for loop."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  }
]